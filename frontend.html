<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kashtkar.ai - AI-Powered Agricultural Intelligence</title>

    <!-- Google Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <!-- Google Maps API -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCL2tcGwvncOE07j2tcibAzMxUpaQBRsi0&libraries=places&callback=initializeGoogleMapsCallback"></script>

    <style>
        :root {
            /* Kashtkar.ai Google Material Design 3 Colors */
            --primary-color: #1a73e8;      /* Google Blue */
            --primary-variant: #1557b0;    /* Darker Blue */
            --secondary-color: #34a853;    /* Google Green */
            --tertiary-color: #fbbc04;     /* Google Yellow */
            --surface: #ffffff;            /* Pure White */
            --surface-variant: #f8f9fa;    /* Light Gray */
            --background: #f1f3f4;         /* Google Background */
            --on-primary: #ffffff;         /* White text on primary */
            --on-surface: #3c4043;         /* Dark Gray */
            --on-surface-variant: #5f6368; /* Medium Gray */
            --on-background: #3c4043;      /* Dark Gray on background */
            --border: #dadce0;             /* Light Border */
            --hover: #f8f9fa;              /* Hover Background */
            --shadow: rgba(60, 64, 67, 0.1); /* Google Shadow */
            --shadow-hover: rgba(60, 64, 67, 0.15);

            /* Chat specific */
            --chat-user-bg: #e8f0fe;       /* Google Blue Light */
            --chat-agent-bg: #f1f3f4;      /* Light Gray */
            --chat-border: #e8eaed;        /* Light Border */

            /* Kashtkar.ai specific */
            --success-color: #34a853;      /* Success Green */
            --warning-color: #fbbc04;      /* Warning Yellow */
            --error-color: #ea4335;        /* Error Red */
            --info-color: #1a73e8;         /* Info Blue */

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 48px;

            /* Typography */
            --font-family: 'Google Sans', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-size-xs: 12px;
            --font-size-sm: 14px;
            --font-size-md: 16px;
            --font-size-lg: 18px;
            --font-size-xl: 20px;
            --font-size-xxl: 24px;
        }

        [data-theme="dark"] {
            /* Dark Theme Colors */
            --primary-color: #8ab4f8;
            --primary-variant: #aecbfa;
            --secondary-color: #81c995;
            --surface: #2d3748;
            --surface-variant: #1e1e1e;
            --background: #121212;
            --on-primary: #000000;
            --on-surface: #e8eaed;
            --on-surface-variant: #9aa0a6;
            --border: #3c4043;
            --hover: #3c4043;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-hover: rgba(0, 0, 0, 0.4);

            /* Chat specific - dark */
            --chat-user-bg: #3c4043;
            --chat-agent-bg: #2d3748;
            --chat-border: #5f6368;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background: var(--background);
            color: var(--on-surface);
            line-height: 1.5;
            overflow: hidden;
        }

        /* App Bar */
        .app-bar {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 0 var(--spacing-lg);
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 3px var(--shadow);
            position: relative;
            z-index: 100;
        }

        .app-bar-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .app-logo {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
        }

        .app-logo::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><g><circle cx="100" cy="100" r="80" fill="none" stroke="%231a73e8" stroke-width="2" opacity="0.3"/><circle cx="100" cy="100" r="65" fill="none" stroke="%231a73e8" stroke-width="2" opacity="0.4"/><circle cx="100" cy="100" r="50" fill="none" stroke="%231a73e8" stroke-width="2" opacity="0.5"/><circle cx="100" cy="100" r="35" fill="none" stroke="%231a73e8" stroke-width="2" opacity="0.6"/><circle cx="100" cy="100" r="20" fill="none" stroke="%231a73e8" stroke-width="2" opacity="0.7"/><g transform="translate(100,85)"><path d="M-8,-5 Q0,-18 8,-5 Q0,-2 -8,-5" fill="%2334a853" opacity="0.9"/><path d="M-6,-3 Q0,-12 6,-3 Q0,2 -6,-3" fill="%2334a853" opacity="0.95"/><path d="M-4,0 Q0,-8 4,0 Q0,5 -4,0" fill="%234caf50"/></g><circle cx="100" cy="100" r="10" fill="%231a73e8" opacity="0.2"/></g></svg>') center/contain no-repeat;
        }

        .app-title {
            font-size: 22px;
            font-weight: 500;
            color: var(--on-surface);
        }

        .app-subtitle {
            font-size: 14px;
            color: var(--on-surface-variant);
            margin-left: var(--spacing-sm);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--secondary-color);
            box-shadow: 0 0 8px currentColor;
        }

        .app-bar-right {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .theme-toggle {
            background: none;
            border: none;
            color: var(--on-surface-variant);
            cursor: pointer;
            padding: var(--spacing-sm);
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background: var(--hover);
            color: var(--on-surface);
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 64px);
            overflow: hidden;
        }

        /* Left Panel - Chat Interface */
        .left-panel {
            width: 45%;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            padding: var(--spacing-xl);
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--surface-variant) 0%, var(--surface) 100%);
            position: relative;
        }

        .chat-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: var(--spacing-xl);
            right: var(--spacing-xl);
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border), transparent);
        }

        .chat-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--on-surface);
            margin-bottom: var(--spacing-xs);
            letter-spacing: -0.5px;
        }

        .chat-subtitle {
            font-size: 14px;
            color: var(--on-surface-variant);
            margin-bottom: var(--spacing-lg);
            line-height: 1.4;
        }

        .agents-selector {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .agent-chip {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--on-surface);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            min-height: 36px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .agent-chip .material-icons {
            font-size: 16px;
        }

        .agent-chip.active {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-variant));
            color: var(--on-primary);
            border-color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.3);
            transform: translateY(-1px);
        }

        .agent-chip:not(.active):hover {
            background: var(--hover);
            border-color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .agent-chip.active:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(26, 115, 232, 0.4);
        }

        .location-tools {
            display: flex;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
        }

        .tool-chip {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .tool-chip.active {
            background: var(--primary-color);
            color: var(--on-primary);
        }

        .tool-chip:not(.active) {
            background: var(--surface-variant);
            color: var(--on-surface-variant);
            border-color: var(--border);
        }

        .tool-chip:not(.active):hover {
            background: var(--hover);
        }

        .message.info {
            align-self: center;
        }

        .avatar.info {
            background: var(--info-color);
            color: var(--on-primary);
        }

        .info-label {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
            color: var(--info-color);
        }

        .chat-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .message {
            display: flex;
            gap: var(--spacing-md);
            max-width: 85%;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.agent {
            align-self: flex-start;
        }

        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 500;
            flex-shrink: 0;
        }

        .avatar.user {
            background: var(--primary-color);
            color: var(--on-primary);
        }

        .avatar.agent {
            background: var(--secondary-color);
            color: var(--on-primary);
        }

        .message-content {
            background: var(--chat-user-bg);
            padding: var(--spacing-md);
            border-radius: 18px;
            border: 1px solid var(--chat-border);
            max-width: 100%;
        }

        .message.user .message-content {
            background: var(--primary-color);
            color: var(--on-primary);
            border-color: var(--primary-color);
        }

        .message-text {
            font-size: 14px;
            line-height: 1.4;
        }

        .agent-label {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
            color: var(--on-surface-variant);
        }

        .message.agent .agent-label {
            color: var(--secondary-color);
        }

        .chat-input-container {
            padding: var(--spacing-lg);
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        .chat-input-wrapper {
            display: flex;
            gap: var(--spacing-sm);
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: var(--spacing-md);
            background: var(--surface-variant);
            color: var(--on-surface);
            font-family: inherit;
            font-size: 14px;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            overflow-y: auto;
            transition: all 0.2s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.1);
        }

        .send-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: var(--primary-color);
            color: var(--on-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px var(--shadow);
        }

        .send-button:hover {
            background: var(--primary-variant);
            box-shadow: 0 2px 6px var(--shadow-hover);
        }

        .send-button:disabled {
            background: var(--on-surface-variant);
            cursor: not-allowed;
        }

        /* Right Panel - Map Interface */
        .right-panel {
            width: 55%;
            background: var(--surface);
            display: flex;
            flex-direction: column;
        }

        .map-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            background: var(--surface-variant);
        }

        .map-title {
            font-size: 20px;
            font-weight: 500;
            color: var(--on-surface);
            margin-bottom: var(--spacing-xs);
        }

        .map-subtitle {
            font-size: 14px;
            color: var(--on-surface-variant);
        }

        .map-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
        }

        .map-control-btn {
            padding: var(--spacing-xs) var(--spacing-md);
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--on-surface);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-control-btn:hover {
            background: var(--hover);
        }

        .map-control-btn.active {
            background: var(--primary-color);
            color: var(--on-primary);
            border-color: var(--primary-color);
        }

        .map-control-btn.location-detection-enabled {
            background: #ff6b35;
            color: white;
            border-color: #ff6b35;
        }

        .map-control-btn.location-detection-disabled {
            background: var(--surface-variant);
            color: var(--on-surface-variant);
        }

        .location-detection-indicator {
            animation: pulse 2s infinite;
        }

        #selected-coordinates {
            font-family: monospace;
        }

        .location-status-bar {
            transition: all 0.3s ease;
        }

        .location-status-bar.hidden {
            display: none;
        }

        .location-detection-indicator {
            position: relative;
            overflow: hidden;
        }

        .location-detection-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(26, 115, 232, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .welcome-dashboard {
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .feature-btn {
            transition: all 0.2s ease;
        }

        .feature-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-overlay {
            position: absolute;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: var(--spacing-md);
            box-shadow: 0 2px 8px var(--shadow);
            max-width: 300px;
        }

        .overlay-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--on-surface);
            margin-bottom: var(--spacing-sm);
        }

        .overlay-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-xs) 0;
            border-bottom: 1px solid var(--border);
        }

        .overlay-item:last-child {
            border-bottom: none;
        }

        .overlay-label {
            font-size: 12px;
            color: var(--on-surface-variant);
        }

        .overlay-value {
            font-size: 12px;
            font-weight: 500;
            color: var(--on-surface);
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--on-surface-variant);
            font-size: 14px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: var(--spacing-sm);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .left-panel, .right-panel {
                width: 100%;
            }

            .left-panel {
                height: 60%;
                border-right: none;
                border-bottom: 1px solid var(--border);
            }

            .right-panel {
                height: 40%;
            }

            .app-bar {
                padding: 0 var(--spacing-md);
            }

            .app-title {
                font-size: 18px;
            }

            .chat-header {
                padding: var(--spacing-lg);
            }

            .chat-title {
                font-size: 20px;
            }

            .agents-selector {
                overflow-x: auto;
                padding-bottom: var(--spacing-xs);
                gap: var(--spacing-xs);
            }

            .agent-chip {
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 12px;
                min-height: 32px;
            }

            .voice-controls {
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            .voice-button {
                width: 40px;
                height: 40px;
            }

            .voice-toggle {
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 12px;
                min-height: 32px;
            }

            .message {
                max-width: 90%;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus styles for accessibility */
        .agent-chip:focus,
        .theme-toggle:focus,
        .chat-input:focus,
        .send-button:focus,
        .map-control-btn:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Voice Interface Styles */
        .voice-controls {
            display: flex;
            gap: var(--spacing-md);
            align-items: center;
            justify-content: flex-start;
            padding: var(--spacing-sm) 0;
            border-top: 1px solid var(--border);
            margin-top: var(--spacing-sm);
        }

        .voice-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: var(--surface);
            color: var(--on-surface-variant);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
        }

        .voice-button:hover {
            background: var(--hover);
            color: var(--on-surface);
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .voice-button.active {
            background: linear-gradient(135deg, var(--secondary-color), #2e7d32);
            color: var(--on-primary);
            border-color: var(--secondary-color);
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
        }

        .voice-button.recording {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            animation: pulse 1.5s infinite;
            border-color: #f44336;
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
        }

        .voice-button.speaking {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            color: white;
            animation: wave 1.5s infinite;
            border-color: #2196f3;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .voice-indicator {
            position: absolute;
            top: -3px;
            right: -3px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--secondary-color);
            box-shadow: 0 0 8px currentColor;
            border: 2px solid var(--surface);
        }

        .voice-button.speaking .voice-indicator {
            background: #2196f3;
            box-shadow: 0 0 8px #2196f3;
        }

        .voice-button.recording .voice-indicator {
            background: #f44336;
            box-shadow: 0 0 8px #f44336;
        }

        .voice-toggle {
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--on-surface);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            min-height: 36px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .voice-toggle:hover {
            background: var(--hover);
            border-color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .voice-toggle.active {
            background: linear-gradient(135deg, var(--secondary-color), #2e7d32);
            color: var(--on-primary);
            border-color: var(--secondary-color);
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
            transform: translateY(-1px);
        }

        .voice-toggle.disabled {
            background: linear-gradient(135deg, var(--error-color), #d32f2f);
            color: white;
            border-color: var(--error-color);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .voice-toggle.active:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 168, 83, 0.4);
        }

        .voice-settings {
            padding: var(--spacing-md);
            border-top: 1px solid var(--border);
            background: var(--surface-variant);
            margin-top: auto;
        }

        .voice-settings-title {
            font-size: 12px;
            font-weight: 500;
            color: var(--on-surface-variant);
            margin-bottom: var(--spacing-sm);
            text-transform: uppercase;
        }

        .voice-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }

        .voice-setting-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .voice-setting-label {
            font-size: 11px;
            color: var(--on-surface-variant);
        }

        .voice-setting-value {
            font-size: 12px;
            color: var(--on-surface);
            font-weight: 500;
        }

        .voice-feedback {
            position: fixed;
            bottom: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: var(--spacing-md);
            box-shadow: 0 4px 12px var(--shadow);
            display: none;
            align-items: center;
            gap: var(--spacing-sm);
            z-index: 1000;
        }

        .voice-feedback.show {
            display: flex;
        }

        .voice-feedback-text {
            font-size: 14px;
            color: var(--on-surface);
        }

        .touch-speak-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: var(--primary-color);
            color: var(--on-primary);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            box-shadow: 0 4px 12px var(--shadow);
            transition: all 0.2s ease;
        }

        .touch-speak-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 6px 16px var(--shadow-hover);
        }

        .touch-speak-button.speaking {
            animation: pulse 1.5s infinite;
        }

        .touch-speak-label {
            font-size: 12px;
            font-weight: 500;
        }

        .touch-speak-icon {
            font-size: 24px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes wave {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.05); }
            75% { transform: scale(0.95); }
        }

        /* RTL Support for Urdu */
        [data-language="ur-PK"] {
            direction: rtl;
            font-family: 'Noto Sans Arabic', 'Arabic Typesetting', serif;
        }

        [data-language="ur-PK"] .message {
            direction: rtl;
        }

        [data-language="ur-PK"] .chat-input {
            direction: rtl;
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            .voice-button {
                border: 2px solid var(--on-surface);
            }

            .voice-indicator {
                border: 2px solid var(--surface);
            }
        }

        /* Large text support */
        .large-text .chat-input,
        .large-text .message-text,
        .large-text .voice-feedback-text {
            font-size: 16px;
        }

        .large-text .voice-button {
            width: 48px;
            height: 48px;
        }
    </style>
</head>
<body>
    <!-- App Bar -->
    <div class="app-bar">
        <div class="app-bar-left">
            <div class="app-logo">K</div>
            <div>
                <div class="app-title">Kashtkar.ai</div>
                <div class="app-subtitle">AI-Powered Agricultural Intelligence</div>
            </div>
        </div>
        <div class="app-bar-right">
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                <span class="material-icons">dark_mode</span>
            </button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Panel - Chat Interface -->
        <div class="left-panel">
            <div class="chat-header">
                <div class="chat-title">AI Agents</div>
                <div class="chat-subtitle">Chat with specialized agricultural agents</div>

                <div class="agents-selector">
                    <div class="agent-chip active" data-agent="sensor" onclick="selectAgent('sensor')">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">thermostat</span>
                        Sensor
                    </div>
                    <div class="agent-chip" data-agent="prediction" onclick="selectAgent('prediction')">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">trending_up</span>
                        Prediction
                    </div>
                    <div class="agent-chip" data-agent="resource" onclick="selectAgent('resource')">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">build</span>
                        Resource
                    </div>
                    <div class="agent-chip" data-agent="market" onclick="selectAgent('market')">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">store</span>
                        Market
                    </div>
                </div>

                <!-- Voice Controls -->
                <div class="voice-controls">
                    <button class="voice-button" onclick="toggleVoiceRecognition()" title="Voice Recognition" id="voiceRecognitionBtn">
                        <span class="material-icons">mic</span>
                        <div class="voice-indicator"></div>
                    </button>
                    <div class="voice-toggle active" onclick="toggleVoiceOutput()" id="voiceToggle" title="Toggle voice output">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">volume_up</span>
                        ON
                    </div>
                </div>

            </div>

            <div class="chat-container">

                <div class="chat-messages" id="chatMessages">
                    <div class="message agent">
                        <div class="avatar agent">S</div>
                        <div class="message-content">
                            <div class="agent-label">Sensor Agent</div>
                            <div class="message-text">Hello! I'm your Sensor Agent. I can provide real-time data about your farm's environmental conditions. The AI automatically detects location names in your questions and shows them on the map. Try asking: "Show me farms in Lahore" or "What are conditions in Karachi?"</div>
                        </div>
                    </div>
                </div>

                <div class="chat-input-container">
                    <div class="chat-input-wrapper">
                        <textarea
                            class="chat-input"
                            id="chatInput"
                            placeholder="Ask me anything about your farm... (e.g., 'Show me farms in Lahore' or 'What are conditions in Karachi?')"
                            rows="1"
                            onkeydown="handleKeyPress(event)"
                        ></textarea>
                        <button class="send-button" onclick="sendMessage()" id="sendButton">
                            <span class="material-icons">send</span>
                        </button>
                    </div>
                </div>

                <!-- Voice Settings Panel -->
                <div class="voice-settings" id="voiceSettingsPanel" style="display: none;">
                    <div class="voice-settings-title">Voice Settings</div>
                    <div class="voice-settings-grid">
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Language</div>
                            <div class="voice-setting-value" id="currentLanguage">English (US)</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Voice Speed</div>
                            <div class="voice-setting-value" id="voiceSpeed">Normal</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Auto Greeting</div>
                            <div class="voice-setting-value" id="autoGreeting">Enabled</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Touch to Speak</div>
                            <div class="voice-setting-value" id="touchToSpeak">Enabled</div>
                        </div>
                    </div>

                    <!-- Voice Diagnostics Section -->
                    <div class="voice-settings-title" style="margin-top: 16px; border-top: 1px solid var(--border); padding-top: 12px;">Diagnostics</div>
                    <div class="voice-settings-grid">
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Recognition Status</div>
                            <div class="voice-setting-value" id="recognitionStatus">Not Initialized</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Synthesis Status</div>
                            <div class="voice-setting-value" id="synthesisStatus">Not Initialized</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Available Voices</div>
                            <div class="voice-setting-value" id="availableVoices">Loading...</div>
                        </div>
                        <div class="voice-setting-item">
                            <div class="voice-setting-label">Current Voice</div>
                            <div class="voice-setting-value" id="currentVoice">None</div>
                        </div>
                    </div>

                    <!-- Test Buttons -->
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border);">
                        <button class="map-control-btn" onclick="testVoiceFeatures()" style="margin-right: 8px;">
                            Run Diagnostics
                        </button>
                        <button class="map-control-btn" onclick="speakText('This is a test of the voice system.')" style="margin-right: 8px;">
                            Test Speech
                        </button>
                        <button class="map-control-btn" onclick="toggleVoiceRecognition()" id="testRecognitionBtn" style="margin-right: 8px;">
                            Test Recognition
                        </button>
                        <button class="map-control-btn" onclick="testLocationDetection()" style="background: #ff6b35; color: white; margin-right: 8px;">
                            Test Location Detection
                        </button>
                        <button class="map-control-btn" onclick="testMapNavigation()" style="background: #2196f3; color: white;">
                            Test Map Navigation
                        </button>
                    </div>

                    <!-- Smart Chat Examples -->
                    <div style="margin-top: 16px; padding: 12px; background: #e8f5e8; border-radius: 8px; border-left: 4px solid var(--secondary-color);">
                        <div class="voice-settings-title" style="margin-bottom: 8px; font-size: 11px; color: var(--secondary-color);">Smart Chat Examples</div>
                        <div style="font-size: 10px; color: var(--on-surface-variant); line-height: 1.4;">
                            <div style="margin-bottom: 4px;"><strong>Try these intelligent queries:</strong></div>
                            <div>• "Show me agricultural data for Lahore"</div>
                            <div>• "What are the conditions in Karachi?"</div>
                            <div>• "Check crop yields in Punjab"</div>
                            <div>• "Weather information for Islamabad"</div>
                            <div>• "How is farming in Peshawar?"</div>
                        </div>
                    </div>

                    <!-- Voice Command Help -->
                    <div style="margin-top: 16px; padding: 12px; background: var(--surface-variant); border-radius: 8px;">
                        <div class="voice-settings-title" style="margin-bottom: 8px; font-size: 11px;">Voice Commands</div>
                        <div id="voiceCommandsHelp" style="font-size: 10px; color: var(--on-surface-variant); line-height: 1.4;">
                            Loading commands...
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Right Panel - Map Interface -->
        <div class="right-panel">

            <div class="map-container">
                <div id="map" style="width: 100%; height: 100%;"></div>

            </div>
        </div>
    </div>

    <!-- Voice Feedback -->
    <div class="voice-feedback" id="voiceFeedback">
        <span class="material-icons" id="voiceFeedbackIcon">mic</span>
        <span class="voice-feedback-text" id="voiceFeedbackText">Listening...</span>
    </div>

    <!-- Touch to Speak Overlay -->
    <div class="touch-speak-overlay" id="touchSpeakOverlay" style="display: none;">
        <button class="touch-speak-button" id="touchSpeakButton">
            <span class="material-icons touch-speak-icon">mic</span>
            <div class="touch-speak-label" id="touchSpeakLabel">Tap to Speak</div>
        </button>
    </div>

    <script>
        // Configuration
        const BACKEND_URL = 'http://localhost:8080';
        const GOOGLE_MAPS_API_KEY = 'AIzaSyCL2tcGwvncOE07j2tcibAzMxUpaQBRsi0'; // Replace with actual API key
        const GOOGLE_AI_STUDIO_API_KEY = 'AIzaSyCbf_5WdnRUQFW-Bc4ay3lbuBH6shVemFE'; // Google AI Studio API key for location detection

        // State management
        let currentAgent = 'sensor';
        let currentTheme = localStorage.getItem('theme') || 'light';
        let map = null;
        let currentMapLayer = 'overview';

        // Agent configurations
        const agents = {
            sensor: {
                name: 'Sensor Agent',
                icon: 'thermostat',
                color: '#34a853',
                description: 'Real-time environmental monitoring'
            },
            prediction: {
                name: 'Prediction Agent',
                icon: 'trending_up',
                color: '#ea8600',
                description: 'AI-powered yield and risk predictions'
            },
            resource: {
                name: 'Resource Agent',
                icon: 'build',
                color: '#1a73e8',
                description: 'Resource optimization and planning'
            },
            market: {
                name: 'Market Agent',
                icon: 'store',
                color: '#9334e6',
                description: 'Market analysis and pricing intelligence'
            }
        };

        // Initialize application
        async function initializeApp() {
            console.log('🚀 Starting Kashtkar.ai application initialization...');

            // Check authentication first
            const isAuthenticated = await checkAuthentication();
            if (!isAuthenticated) {
                console.log('🔐 User not authenticated');

                // For demo purposes, show a demo access option
                if (confirm('Authentication required. Click OK to use demo access or Cancel to go to login.')) {
                    console.log('🎭 Using demo access...');
                    // Set demo user for demonstration
                    localStorage.setItem('kashtkar_token', 'demo_token_active');
                    localStorage.setItem('kashtkar_user', JSON.stringify({
                        id: 'demo_user',
                        name: 'Demo Farmer',
                        email: 'demo@kashtkar.ai',
                        role: 'farmer',
                        isDemo: true
                    }));
                } else {
                    console.log('🔐 Redirecting to login...');
                    window.location.href = 'login.html';
                    return;
                }
            }

            console.log('✅ User authenticated, continuing initialization...');

            initializeTheme();
            initializeChat();

            console.log('🗺️ Initializing map...');
            await initializeMap();
            console.log('✅ Map initialization completed');

            console.log('🔌 Testing backend connection...');
            await testBackendConnection();

            console.log('📍 Initializing location detection...');
            initializeLocationDetection();

            console.log('✅ Kashtkar.ai application fully initialized');

            // Auto-update data every 30 seconds
            setInterval(updateRealTimeData, 30000);
        }

        // Check user authentication status
        async function checkAuthentication() {
            try {
                const token = localStorage.getItem('kashtkar_token');
                const userData = localStorage.getItem('kashtkar_user');

                if (!token) {
                    console.log('🔐 No authentication token found');
                    return false;
                }

                // Check for demo token (easy bypass)
                if (token === 'demo_token_active' || token.startsWith('kashtkar_demo_token_') || token.startsWith('kashtkar_token_')) {
                    console.log('🎭 Demo token detected, allowing access');
                    if (userData) {
                        try {
                            const user = JSON.parse(userData);
                            updateUserInterface(user);
                            return true;
                        } catch (error) {
                            console.error('❌ Demo user data parsing failed:', error);
                        }
                    }
                }

                // For real tokens, verify with backend
                if (token.startsWith('kashtkar_token_') || token.startsWith('kashtkar_google_token_')) {
                    const response = await fetch('/api/auth/verify', {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json',
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.valid) {
                            console.log('✅ User authentication verified');
                            // Update UI with user info
                            updateUserInterface(data.user);
                            return true;
                        }
                    }
                }

                // Token invalid, remove it
                localStorage.removeItem('kashtkar_token');
                localStorage.removeItem('kashtkar_user');
                return false;

            } catch (error) {
                console.error('❌ Authentication check failed:', error);
                return false;
            }
        }

        // Update UI with authenticated user information
        function updateUserInterface(user) {
            // Add user menu to app bar
            const appBarRight = document.querySelector('.app-bar-right');
            if (appBarRight && !document.querySelector('.user-menu')) {
                const userMenu = document.createElement('div');
                userMenu.className = 'user-menu';
                userMenu.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; cursor: pointer;" onclick="toggleUserMenu()">
                        <img src="${user.avatar}" alt="${user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--border);">
                        <span style="font-size: 14px; color: var(--on-surface);">${user.name}</span>
                        <span class="material-icons" style="font-size: 16px; color: var(--on-surface-variant);">expand_more</span>
                    </div>
                    <div id="userDropdown" class="user-dropdown" style="display: none; position: absolute; top: 100%; right: 0; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 4px 12px var(--shadow); z-index: 1000; min-width: 200px;">
                        <div style="padding: 16px;">
                            <div style="font-size: 14px; color: var(--on-surface); margin-bottom: 4px;">${user.name}</div>
                            <div style="font-size: 12px; color: var(--on-surface-variant);">${user.email}</div>
                        </div>
                        <hr style="border: none; border-top: 1px solid var(--border); margin: 0;">
                        <div style="padding: 8px;">
                            <button onclick="logout()" style="width: 100%; padding: 8px 16px; background: none; border: none; color: var(--error-color); font-size: 14px; cursor: pointer; text-align: left;">Sign Out</button>
                        </div>
                    </div>
                `;

                appBarRight.insertBefore(userMenu, appBarRight.firstChild);
            }
        }

        // Toggle user dropdown menu
        function toggleUserMenu() {
            const dropdown = document.getElementById('userDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Logout function
        function logout() {
            localStorage.removeItem('kashtkar_token');
            localStorage.removeItem('kashtkar_user');
            window.location.href = 'login.html';
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const userMenu = document.querySelector('.user-menu');
            const dropdown = document.getElementById('userDropdown');

            if (userMenu && dropdown && !userMenu.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Theme management
        function initializeTheme() {
            document.documentElement.setAttribute('data-theme', currentTheme);
            updateThemeIcon();

            // Add theme to localStorage
            localStorage.setItem('theme', currentTheme);
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            localStorage.setItem('theme', currentTheme);
            updateThemeIcon();
        }

        function updateThemeIcon() {
            const themeToggle = document.querySelector('.theme-toggle .material-icons');
            themeToggle.textContent = currentTheme === 'light' ? 'dark_mode' : 'light_mode';
        }

        // Chat interface
        function initializeChat() {
            const chatInput = document.getElementById('chatInput');
            const chatMessages = document.getElementById('chatMessages');

            // Auto-resize textarea
            chatInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';
            });

            // Focus chat input
            chatInput.focus();
        }

        function selectAgent(agentType) {
            currentAgent = agentType;

            // Update active agent chip
            document.querySelectorAll('.agent-chip').forEach(chip => {
                chip.classList.remove('active');
            });
            document.querySelector(`[data-agent="${agentType}"]`).classList.add('active');

            // Add welcome message for new agent
            addAgentMessage(`Hello! I'm the ${agents[agentType].name}. ${agents[agentType].description}. How can I help you today?`);
        }

        async function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();

            if (!message) return;

            // Hide welcome dashboard on first interaction
            hideWelcomeDashboard();

            // Add user message
            addUserMessage(message);

            // Clear input
            chatInput.value = '';
            chatInput.style.height = 'auto';

            // Disable send button temporarily
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            // Check for location mentions and process using new workflow
            try {
                const locationDetected = await detectAndProcessLocation(message);
                if (locationDetected) {
                    // If location was detected and processed, just re-enable the button
                    sendButton.disabled = false;
                    return;
                }
            } catch (error) {
                console.error('❌ Location detection error:', error);
            }

            // Process message based on current agent
            setTimeout(() => {
                processAgentResponse(message);
                sendButton.disabled = false;
            }, 1000);
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function addUserMessage(text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = createMessageElement('user', text);
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addAgentMessage(text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = createMessageElement('agent', text);
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function createMessageElement(type, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;

            const avatarDiv = document.createElement('div');
            avatarDiv.className = `avatar ${type}`;
            avatarDiv.textContent = type === 'user' ? 'U' : (type === 'info' ? 'i' : 'M');

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            if (type === 'agent') {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'agent-label';
                labelDiv.textContent = 'Map Assistant';
                contentDiv.appendChild(labelDiv);
            } else if (type === 'info') {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'info-label';
                labelDiv.textContent = 'Map Explorer';
                contentDiv.appendChild(labelDiv);
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.textContent = text;
            contentDiv.appendChild(textDiv);

            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);

            return messageDiv;
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Agent response processing
        async function processAgentResponse(userMessage) {
            try {
                console.log(`🤖 Processing response for agent: ${currentAgent}, message: ${userMessage}`);
                let response;

                switch (currentAgent) {
                    case 'sensor':
                        console.log('📡 Calling sensor agent...');
                        response = await getSensorResponse(userMessage);
                        break;
                    case 'prediction':
                        console.log('🔮 Calling prediction agent...');
                        response = await getPredictionResponse(userMessage);
                        break;
                    case 'resource':
                        console.log('🔧 Calling resource agent...');
                        response = await getResourceResponse(userMessage);
                        break;
                    case 'market':
                        console.log('📈 Calling market agent...');
                        response = await getMarketResponse(userMessage);
                        break;
                    default:
                        console.log('❓ Unknown agent:', currentAgent);
                        response = "I'm not sure how to help with that. Can you ask me something related to agricultural monitoring?";
                }

                console.log(`✅ Agent response: ${response}`);
                addAgentMessage(response);
                updateMapData();

            } catch (error) {
                console.error('❌ Error processing agent response:', error);
                addAgentMessage(`❌ Error: ${error.message}. Please check the console for details.`);
            }
        }

        // API communication
        async function makeAPICall(endpoint) {
            try {
                console.log(`🔄 Making API call to: ${BACKEND_URL}${endpoint}`);
                const response = await fetch(`${BACKEND_URL}${endpoint}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    mode: 'cors'
                });

                console.log(`📡 Response status: ${response.status}`);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const data = await response.json();
                console.log(`✅ API call successful:`, data);
                return data;
            } catch (error) {
                console.error(`❌ API Error for ${endpoint}:`, error.message);
                throw error;
            }
        }

        async function testBackendConnection() {
            try {
                const status = await makeAPICall('/api/status');
                console.log(`✅ Backend connected - Version: ${status.version}`);
                addAgentMessage("✅ Backend connection established. I'm ready to help!");
            } catch (error) {
                console.error('❌ Backend connection failed:', error);
                addAgentMessage("⚠️ I'm having trouble connecting to the backend. Some features may be limited.");
            }
        }

        // Agent-specific responses
        async function getSensorResponse(message) {
            const data = await makeAPICall('/api/sensor');

            if (message.toLowerCase().includes('temperature')) {
                return `Current temperature is ${data.temperature.toFixed(1)}°C. ${getTemperatureAdvice(data.temperature)}`;
            } else if (message.toLowerCase().includes('humidity')) {
                return `Current humidity is ${data.humidity.toFixed(1)}%. ${getHumidityAdvice(data.humidity)}`;
            } else if (message.toLowerCase().includes('soil')) {
                return `Current soil moisture is ${data.soilMoisture.toFixed(1)}%. ${getSoilAdvice(data.soilMoisture)}`;
            } else {
                return `Current conditions: ${data.temperature.toFixed(1)}°C, ${data.humidity.toFixed(1)}% humidity, ${data.soilMoisture.toFixed(1)}% soil moisture. Location: ${data.location.region}, ${data.location.district}.`;
            }
        }

        async function getPredictionResponse(message) {
            const data = await makeAPICall('/api/predictions');

            if (message.toLowerCase().includes('yield')) {
                return `Yield prediction: ${data.yield.predictedYield} kg/acre with ${data.yield.score}% confidence. ${getYieldAdvice(data.yield)}`;
            } else if (message.toLowerCase().includes('pest')) {
                return `Pest risk level: ${data.pestRisk.level} (${data.pestRisk.score}/100). ${getPestAdvice(data.pestRisk)}`;
            } else if (message.toLowerCase().includes('harvest')) {
                return `Harvest is predicted in ${data.harvest.daysToHarvest} days. ${getHarvestAdvice(data.harvest)}`;
            } else {
                return `Key predictions: ${data.yield.predictedYield} kg/acre yield, ${data.pestRisk.level} pest risk, harvest in ${data.harvest.daysToHarvest} days.`;
            }
        }

        async function getResourceResponse(message) {
            const data = await makeAPICall('/api/resources');

            if (message.toLowerCase().includes('water')) {
                return `Water requirement: ${Math.round(data.water.amount)}L. ${getWaterAdvice(data.water)}`;
            } else if (message.toLowerCase().includes('fertilizer')) {
                return `Fertilizer needed: N:${data.fertilizer.nitrogen}kg, P:${data.fertilizer.phosphorus}kg, K:${data.fertilizer.potassium}kg.`;
            } else if (message.toLowerCase().includes('cost')) {
                return `Total estimated cost: ₹${data.costAnalysis.total}. ${getCostAdvice(data.costAnalysis)}`;
            } else {
                return `Resource needs: ${Math.round(data.water.amount)}L water, ₹${data.costAnalysis.total} total cost, ${data.labor.total} workers needed.`;
            }
        }

        async function getMarketResponse(message) {
            const data = await makeAPICall('/api/market');

            if (message.toLowerCase().includes('price')) {
                return `Current price: ₹${data.price_prediction.current_price}/kg, predicted: ₹${data.price_prediction.predicted_price}/kg. Trend: ${data.price_prediction.trend}.`;
            } else if (message.toLowerCase().includes('sell')) {
                return `Selling recommendation: ${data.selling_recommendation.action}. ${getSellingAdvice(data.selling_recommendation)}`;
            } else if (message.toLowerCase().includes('risk')) {
                return `Market risk level: ${data.risk_assessment.overall_risk}. Confidence: ${data.price_prediction.confidence}%.`;
            } else {
                return `Market data: ₹${data.price_prediction.current_price}/kg current, ₹${data.price_prediction.predicted_price}/kg predicted, ${data.selling_recommendation.action} recommended action.`;
            }
        }

        // Advice functions
        function getTemperatureAdvice(temp) {
            if (temp < 15) return "This is quite cool - consider protective measures for sensitive crops.";
            if (temp > 35) return "High temperature alert - ensure adequate irrigation.";
            return "Temperature is optimal for crop growth.";
        }

        function getHumidityAdvice(humidity) {
            if (humidity < 40) return "Low humidity - increase irrigation frequency.";
            if (humidity > 80) return "High humidity - monitor for fungal diseases.";
            return "Humidity levels are good.";
        }

        function getSoilAdvice(moisture) {
            if (moisture < 30) return "Soil is dry - irrigation recommended.";
            if (moisture > 70) return "Soil is very wet - reduce watering.";
            return "Soil moisture is adequate.";
        }

        function getYieldAdvice(yield) {
            if (yield.score < 50) return "Yield may be below average - consider intervention.";
            if (yield.score > 80) return "Excellent yield expected!";
            return "Yield prediction is moderate.";
        }

        function getPestAdvice(pestRisk) {
            if (pestRisk.score > 70) return "High pest risk - consider preventive measures.";
            if (pestRisk.score < 30) return "Low pest risk - conditions are favorable.";
            return "Moderate pest risk - regular monitoring recommended.";
        }

        function getHarvestAdvice(harvest) {
            if (harvest.daysToHarvest < 7) return "Harvest window approaching!";
            if (harvest.daysToHarvest > 30) return "Still some time before harvest.";
            return "Harvest preparations should begin soon.";
        }

        function getWaterAdvice(water) {
            if (water.amount > 1000) return "High water requirement - check irrigation system.";
            if (water.amount < 200) return "Low water requirement - conserve water.";
            return "Water requirement is moderate.";
        }

        function getCostAdvice(cost) {
            if (cost.total > 50000) return "High cost projection - review expenses.";
            if (cost.total < 10000) return "Cost-effective operations.";
            return "Moderate cost structure.";
        }

        function getSellingAdvice(recommendation) {
            if (recommendation.action.includes('hold')) return "Market conditions suggest waiting for better prices.";
            if (recommendation.action.includes('sell')) return "Good time to sell with current market trends.";
            return "Monitor market closely for optimal timing.";
        }

        // Map integration
        async function initializeMap() {
            try {
                // Check if Google Maps API is loaded
                if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                    console.log('⏳ Waiting for Google Maps API to load...');
                    // Wait for API to load
                    await new Promise((resolve, reject) => {
                        let attempts = 0;
                        const checkGoogle = () => {
                            attempts++;
                            if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
                                resolve();
                            } else if (attempts < 50) { // Wait up to 5 seconds
                                setTimeout(checkGoogle, 100);
                            } else {
                                reject(new Error('Google Maps API failed to load'));
                            }
                        };
                        checkGoogle();
                    });
                }

                // Default coordinates (you can replace with actual farm coordinates)
                const defaultLocation = { lat: 28.6139, lng: 77.2090 }; // New Delhi coordinates

                map = new google.maps.Map(document.getElementById('map'), {
                    center: defaultLocation,
                    zoom: 15,
                    styles: getMapStyles(),
                    mapTypeControl: false,
                    streetViewControl: false,
                    fullscreenControl: false
                });

                // Add marker for farm location
                new google.maps.Marker({
                    position: defaultLocation,
                    map: map,
                    title: 'Farm Location',
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: '#34a853',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2
                    }
                });

                console.log('✅ Map initialized successfully');

            } catch (error) {
                console.error('❌ Map initialization failed:', error);
                const mapElement = document.getElementById('map');
                mapElement.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Map loading... (${error.message})</span>
                    </div>
                `;
            }
        }

        function getMapStyles() {
            return [
                {
                    featureType: 'all',
                    elementType: 'geometry',
                    stylers: [{ color: '#f5f5f5' }]
                },
                {
                    featureType: 'water',
                    elementType: 'geometry',
                    stylers: [{ color: '#c9c9c9' }]
                },
                {
                    featureType: 'landscape',
                    elementType: 'geometry',
                    stylers: [{ color: '#f5f5f5' }]
                }
            ];
        }

        function switchMapLayer(layer) {
            currentMapLayer = layer;

            // Update active button
            document.querySelectorAll('.map-control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-layer="${layer}"]`).classList.add('active');

            // Update map overlay
            updateMapOverlay(layer);
        }

        function updateMapOverlay(layer) {
            const overlay = document.getElementById('mapOverlay');

            // For now, show overlay on overview layer
            overlay.style.display = layer === 'overview' ? 'block' : 'none';
        }

        function updateMapData() {
            // Update overlay values with real data
            // This would be called after API responses
            updateMapOverlay(currentMapLayer);
        }

        // Real-time data updates
        async function updateRealTimeData() {
            try {
                const sensorData = await makeAPICall('/api/sensor');

                // Update map overlay
                document.getElementById('tempValue').textContent = `${sensorData.temperature.toFixed(1)}°C`;
                document.getElementById('humidityValue').textContent = `${sensorData.humidity.toFixed(1)}%`;
                document.getElementById('soilValue').textContent = `${sensorData.soilMoisture.toFixed(1)}%`;

                // Update yield data if available
                try {
                    const predictionData = await makeAPICall('/api/predictions');
                    document.getElementById('yieldValue').textContent = `${predictionData.yield.predictedYield} kg/acre`;
                } catch (error) {
                    console.log('Prediction data not available for overlay update');
                }

            } catch (error) {
                console.log('Real-time data update failed:', error);
            }
        }

        // Test all agents function (for debugging)
        async function testAllAgents() {
            console.log('🧪 Testing all agents...');
            const originalAgent = currentAgent;

            const agentsToTest = ['sensor', 'prediction', 'resource', 'market'];
            const results = {};

            for (const agent of agentsToTest) {
                try {
                    console.log(`🧪 Testing ${agent} agent...`);
                    currentAgent = agent;

                    let response;
                    switch (agent) {
                        case 'sensor':
                            response = await getSensorResponse('temperature');
                            break;
                        case 'prediction':
                            response = await getPredictionResponse('yield');
                            break;
                        case 'resource':
                            response = await getResourceResponse('water');
                            break;
                        case 'market':
                            response = await getMarketResponse('price');
                            break;
                    }

                    results[agent] = { success: true, response: response };
                    console.log(`✅ ${agent} agent working:`, response);

                } catch (error) {
                    results[agent] = { success: false, error: error.message };
                    console.error(`❌ ${agent} agent failed:`, error.message);
                }
            }

            currentAgent = originalAgent;
            console.log('🧪 Test results:', results);

            // Show results in chat
            addAgentMessage(`🧪 Agent Test Results:
Sensor: ${results.sensor.success ? '✅' : '❌'}
Prediction: ${results.prediction.success ? '✅' : '❌'}
Resource: ${results.resource.success ? '✅' : '❌'}
Market: ${results.market.success ? '✅' : '❌'}

Check console (F12) for detailed results.`);

            return results;
        }

        // Make test function globally available
        window.testAllAgents = testAllAgents;

        // Initialize when DOM is loaded and Google Maps API is ready
        function initializeGoogleMapsCallback() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeApp);
            } else {
                initializeApp();
            }
        }

        // Check if Google Maps API is already loaded
        if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
            initializeGoogleMapsCallback();
        } else {
            // Wait for Google Maps API to load
            window.initializeGoogleMapsCallback = initializeGoogleMapsCallback;
        }

        // Handle window resize for responsive design
        window.addEventListener('resize', function() {
            if (map) {
                google.maps.event.trigger(map, 'resize');
            }
        });

        // ===== AGRISWARM MAP SEARCH AND SELECTION WORKFLOW =====

        // Location selection state
        let selectedLat = null;
        let selectedLng = null;
        let locationSelectionState = {
            isSearching: false,
            hasSelection: false
        };

        // Location detection state (for backward compatibility)
        let locationDetectionState = {
            detectionEnabled: true,
            isProcessing: false,
            lastDetectedLocation: null
        };

        // Detect and process location mentions in messages
        async function detectAndProcessLocation(message) {
            if (!locationDetectionState.detectionEnabled || locationDetectionState.isProcessing) {
                return false;
            }

            try {
                locationDetectionState.isProcessing = true;
                console.log('🔍 Detecting location in message:', message);

                // Use Google AI Studio to detect and get coordinates for place names
                const locationData = await getLocationFromAIStudio(message);

                if (locationData && locationData.coordinates) {
                    console.log('📍 Location detected:', locationData);

                    // Update map to show the detected location
                    await navigateMapToLocation(locationData.coordinates, locationData.placeName);

                    // Show location detection feedback
                    showLocationDetectionFeedback(locationData);

                    locationDetectionState.lastDetectedLocation = locationData;
                    return true;
                }

                return false;

            } catch (error) {
                console.error('❌ Location detection error:', error);
                return false;
            } finally {
                locationDetectionState.isProcessing = false;
            }
        }

        // Get location data from Google AI Studio API
        async function getLocationFromAIStudio(message) {
            try {
                console.log('🤖 Calling Google AI Studio API for location detection...');

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GOOGLE_AI_STUDIO_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Extract any place names or locations mentioned in this text and provide their coordinates. Return ONLY a JSON object with this exact format: {"placeName": "extracted place name", "coordinates": {"lat": latitude, "lng": longitude}} or {"placeName": null, "coordinates": null} if no location found. Text: "${message}"`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 100
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`AI Studio API error: ${response.status} - ${response.statusText}`);
                }

                const data = await response.json();
                console.log('🤖 AI Studio response received:', data);

                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const aiResponse = data.candidates[0].content.parts[0].text.trim();
                    console.log('🤖 AI response text:', aiResponse);

                    try {
                        // Try to parse the JSON response from AI
                        const locationResult = JSON.parse(aiResponse);
                        console.log('🤖 Parsed location result:', locationResult);

                        if (locationResult.placeName && locationResult.coordinates) {
                            const coordinates = {
                                lat: parseFloat(locationResult.coordinates.lat),
                                lng: parseFloat(locationResult.coordinates.lng)
                            };

                            // Validate coordinates
                            if (isValidCoordinate(coordinates.lat, coordinates.lng)) {
                                return {
                                    placeName: locationResult.placeName,
                                    coordinates: coordinates,
                                    confidence: 'high',
                                    source: 'ai_studio'
                                };
                            } else {
                                console.warn('⚠️ Invalid coordinates from AI:', coordinates);
                            }
                        }
                    } catch (parseError) {
                        console.warn('⚠️ Failed to parse AI response as JSON:', aiResponse);
                        console.warn('Parse error:', parseError);
                        // Try to extract location using regex fallback
                        return extractLocationWithRegex(message);
                    }
                }

                return null;

            } catch (error) {
                console.error('❌ AI Studio API call failed:', error);
                console.log('🔄 Falling back to regex-based location extraction...');
                // Fallback to regex-based extraction
                return extractLocationWithRegex(message);
            }
        }

        // Validate coordinate values
        function isValidCoordinate(lat, lng) {
            return (
                typeof lat === 'number' && typeof lng === 'number' &&
                lat >= -90 && lat <= 90 &&
                lng >= -180 && lng <= 180 &&
                !isNaN(lat) && !isNaN(lng)
            );
        }

        // Fallback location extraction using regex and known locations
        function extractLocationWithRegex(message) {
            const lowerMessage = message.toLowerCase();

            // Common Pakistani cities and locations
            const knownLocations = {
                'lahore': { lat: 31.5204, lng: 74.3587, name: 'Lahore' },
                'karachi': { lat: 24.8607, lng: 67.0011, name: 'Karachi' },
                'islamabad': { lat: 33.6846, lng: 73.0479, name: 'Islamabad' },
                'rawalpindi': { lat: 33.5651, lng: 73.0169, name: 'Rawalpindi' },
                'peshawar': { lat: 34.0151, lng: 71.5249, name: 'Peshawar' },
                'quetta': { lat: 30.1798, lng: 66.9750, name: 'Quetta' },
                'multan': { lat: 30.1575, lng: 71.5249, name: 'Multan' },
                'faisalabad': { lat: 31.4504, lng: 73.1350, name: 'Faisalabad' },
                'sialkot': { lat: 32.4945, lng: 74.5229, name: 'Sialkot' },
                'gujranwala': { lat: 32.1877, lng: 74.1945, name: 'Gujranwala' },
                'hyderabad': { lat: 25.3960, lng: 68.3578, name: 'Hyderabad' },
                'sukkur': { lat: 27.7054, lng: 68.8574, name: 'Sukkur' },
                'larkana': { lat: 27.5609, lng: 68.2264, name: 'Larkana' },
                'punjab': { lat: 31.1704, lng: 72.7097, name: 'Punjab' },
                'sindh': { lat: 25.8943, lng: 68.5247, name: 'Sindh' },
                'khyber pakhtunkhwa': { lat: 34.9526, lng: 72.3311, name: 'Khyber Pakhtunkhwa' },
                'balochistan': { lat: 28.4907, lng: 65.0960, name: 'Balochistan' }
            };

            // Check for known locations
            for (const [key, location] of Object.entries(knownLocations)) {
                if (lowerMessage.includes(key)) {
                    return {
                        placeName: location.name,
                        coordinates: { lat: location.lat, lng: location.lng },
                        confidence: 'medium'
                    };
                }
            }

            return null;
        }

        // Navigate map to detected location
        async function navigateMapToLocation(coordinates, placeName) {
            try {
                console.log(`🗺️ Navigating map to: ${placeName} (${coordinates.lat}, ${coordinates.lng})`);

                // Ensure map is initialized
                if (!map) {
                    console.warn('⚠️ Map not initialized yet, waiting...');
                    await waitForMapInitialization();
                }

                if (!map) {
                    console.error('❌ Map failed to initialize');
                    return;
                }

                // Validate coordinates
                if (!coordinates || typeof coordinates.lat !== 'number' || typeof coordinates.lng !== 'number') {
                    console.error('❌ Invalid coordinates:', coordinates);
                    return;
                }

                // Create new position with validated coordinates
                const newPosition = new google.maps.LatLng(
                    parseFloat(coordinates.lat),
                    parseFloat(coordinates.lng)
                );

                console.log('📍 Moving map to coordinates:', newPosition.lat(), newPosition.lng());

                // Remove existing location marker
                if (window.currentLocationMarker) {
                    window.currentLocationMarker.setMap(null);
                }

                // Add new location marker first
                window.currentLocationMarker = new google.maps.Marker({
                    position: newPosition,
                    map: map,
                    title: placeName,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 16,
                        fillColor: '#ff6b35',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 3
                    },
                    animation: google.maps.Animation.DROP
                });

                // Add info window
                const infoWindow = new google.maps.InfoWindow({
                    content: `<div style="font-weight: bold; color: #333;">📍 ${placeName}</div>
                              <div style="font-size: 12px; color: #666;">Location detected from your query</div>`
                });

                window.currentLocationMarker.addListener('click', () => {
                    infoWindow.open(map, window.currentLocationMarker);
                });

                // Pan to location with animation
                map.panTo(newPosition);

                // Set zoom level after pan animation completes
                setTimeout(() => {
                    map.setZoom(12);
                    console.log('✅ Map zoom set to level 12');
                }, 500);

                // Show info window after zoom
                setTimeout(() => {
                    infoWindow.open(map, window.currentLocationMarker);
                    console.log('✅ Info window displayed');
                }, 1000);

                // Update map overlay with location info
                updateMapOverlayWithLocation(placeName, coordinates);

                console.log('✅ Map navigation completed successfully');

            } catch (error) {
                console.error('❌ Map navigation error:', error);
                console.error('❌ Error details:', {
                    coordinates: coordinates,
                    placeName: placeName,
                    mapExists: !!map,
                    mapCenter: map ? map.getCenter() : 'N/A'
                });
            }
        }

        // Wait for map initialization
        function waitForMapInitialization() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const checkMap = () => {
                    attempts++;
                    if (map && google && google.maps) {
                        console.log('✅ Map is ready');
                        resolve();
                    } else if (attempts < 50) { // Wait up to 5 seconds
                        setTimeout(checkMap, 100);
                    } else {
                        reject(new Error('Map initialization timeout'));
                    }
                };
                checkMap();
            });
        }

        // Update map overlay with location information
        function updateMapOverlayWithLocation(placeName, coordinates) {
            const overlay = document.getElementById('mapOverlay');
            if (overlay) {
                // Add location info to overlay
                const locationInfo = document.createElement('div');
                locationInfo.className = 'overlay-item';
                locationInfo.innerHTML = `
                    <span class="overlay-label">Detected Location</span>
                    <span class="overlay-value" style="color: #ff6b35;">${placeName}</span>
                `;

                // Clear existing location info
                const existingLocationInfo = overlay.querySelector('.location-info');
                if (existingLocationInfo) {
                    existingLocationInfo.remove();
                }

                // Add new location info at the top
                locationInfo.classList.add('location-info');
                const firstItem = overlay.querySelector('.overlay-item');
                if (firstItem) {
                    overlay.insertBefore(locationInfo, firstItem);
                } else {
                    overlay.appendChild(locationInfo);
                }

                overlay.style.display = 'block';
            }
        }

        // Show location detection feedback
        function showLocationDetectionFeedback(locationData) {
            // Add visual feedback in chat
            const feedbackMessage = `📍 I detected a location in your message: **${locationData.placeName}**. I've updated the map to show this location.`;
            addAgentMessage(feedbackMessage);

            // Show brief notification
            showVoiceFeedback(`📍 Showing ${locationData.placeName} on map`, 'place');

            // Speak the feedback if voice is enabled
            if (voiceState.isSpeaking) {
                speakText(`Location detected: ${locationData.placeName}. Map updated.`);
            }
        }

        // Toggle location detection
        function toggleLocationDetection() {
            locationDetectionState.detectionEnabled = !locationDetectionState.detectionEnabled;
            const status = locationDetectionState.detectionEnabled ? 'enabled' : 'disabled';
            console.log(`🔍 Location detection ${status}`);

            // Update button appearance and status bar visibility
            updateLocationDetectionUI();

            if (voiceState.isSpeaking) {
                speakText(`Location detection ${status}`);
            }

            return locationDetectionState.detectionEnabled;
        }

        // Update location detection UI elements
        function updateLocationDetectionUI() {
            const button = document.getElementById('locationDetectionBtn');
            const statusBar = document.getElementById('locationStatusBar');

            if (button) {
                button.classList.remove('location-detection-enabled', 'location-detection-disabled');
                button.innerHTML = locationDetectionState.detectionEnabled
                    ? '<span class="material-icons" style="font-size: 12px;">toggle_on</span>'
                    : '<span class="material-icons" style="font-size: 12px;">toggle_off</span>';

                if (locationDetectionState.detectionEnabled) {
                    button.classList.add('location-detection-enabled');
                    button.title = 'Location detection is enabled - Click to disable';
                } else {
                    button.classList.add('location-detection-disabled');
                    button.title = 'Location detection is disabled - Click to enable';
                }
            }

            // Show/hide status bar
            if (statusBar) {
                statusBar.classList.toggle('hidden', !locationDetectionState.detectionEnabled);
            }
        }

        // Initialize location detection UI
        function initializeLocationDetection() {
            updateLocationDetectionUI();
            console.log('🔍 Location detection initialized, enabled by default');

            // Hide welcome dashboard after 10 seconds or on first interaction
            setTimeout(() => {
                hideWelcomeDashboard();
            }, 10000);
        }

        // Hide welcome dashboard
        function hideWelcomeDashboard() {
            const dashboard = document.getElementById('welcomeDashboard');
            if (dashboard) {
                dashboard.style.display = 'none';
            }
        }

        // Show feature demonstrations
        function showFeatureDemo(feature) {
            hideWelcomeDashboard();

            switch (feature) {
                case 'location':
                    // Add a location query to chat and process it
                    setTimeout(() => {
                        document.getElementById('chatInput').value = 'Show me agricultural data for Lahore';
                        sendMessage();
                    }, 500);
                    break;

                case 'voice':
                    // Show voice settings
                    toggleVoiceSettings();
                    if (voiceState.isSpeaking) {
                        speakText('Voice features are ready! Say start to begin voice recognition.');
                    }
                    break;

                case 'agents':
                    // Show agent information
                    addAgentMessage('🤖 I have specialized AI agents for different farming needs: Sensor Agent (🌡️), Prediction Agent (🔮), Resource Agent (🔧), and Market Agent (📈). Click on any agent to chat with them!');
                    break;
            }
        }

        // ===== WEB SPEECH API IMPLEMENTATION =====

        // Voice configuration - English only with voice toggle
        const voiceConfig = {
            defaultLanguage: "en-US",
            fallbackLanguage: "en-US",
            autoDetectLanguage: false,
            voiceGreetingEnabled: true,
            touchToSpeakEnabled: true,
            continuousListening: false,
            voiceSpeedControl: true,
            voiceOutputEnabled: true,

            supportedLanguages: [
                {
                    code: "en-US",
                    name: "English (US)",
                    nativeName: "English (United States)",
                    speechRecognitionCode: "en-US",
                    speechSynthesisVoice: "en-US",
                    isRTL: false,
                    isPrimary: true,
                    confidence: "high"
                }
            ],

            voiceFeatures: {
                greeting: {
                    enabled: true,
                    messages: {
                        "en-US": "Welcome to Kashtkar.ai! I'm here to help you with your farming needs. You can ask me about crops, weather, or market information."
                    },
                    triggerOnLaunch: true,
                    welcomeDelay: 1000
                },

                touchToSpeak: {
                    enabled: true,
                    buttonLabels: {
                        "en-US": {
                            "crops": "Crops",
                            "weather": "Weather",
                            "fertilizer": "Fertilizer",
                            "irrigation": "Irrigation",
                            "pestControl": "Pest Control",
                            "market": "Market",
                            "help": "Help",
                            "settings": "Settings"
                        }
                    },
                    speakOnTouch: true,
                    hapticFeedback: true
                },

                audioInstructions: {
                    enabled: true,
                    stepByStep: true,
                    contextAware: true,
                    instructions: {
                        navigation: {
                            "en-US": "Touch to navigate to this section"
                        },
                        input: {
                            "en-US": "Speak or type your information"
                        },
                        confirmation: {
                            "en-US": "Say yes to confirm"
                        }
                    }
                },

                voiceCommands: {
                    enabled: true,
                    keywords: {
                        "en-US": {
                            "start": ["start", "begin", "go", "listen"],
                            "stop": ["stop", "end", "finish", "quiet"],
                            "help": ["help", "support", "assist", "commands"],
                            "repeat": ["repeat", "again", "once more", "say again"],
                            "home": ["home", "main", "back", "menu"],
                            "settings": ["settings", "options", "preferences", "configure"],
                            "voice": ["voice on", "voice off", "enable voice", "disable voice", "turn on voice", "turn off voice"]
                        }
                    }
                }
            }
        };

        // Voice state management
        let voiceState = {
            currentLanguage: voiceConfig.defaultLanguage,
            isListening: false,
            isSpeaking: false,
            recognition: null,
            synthesis: null,
            voices: [],
            currentVoice: null,
            touchToSpeakMode: false,
            greetingPlayed: false,
            voiceOutputEnabled: voiceConfig.voiceOutputEnabled,
            // Support for Urdu speech recognition even when voice output is disabled
            supportedRecognitionLanguages: [
                { code: 'en-US', name: 'English' },
                { code: 'ur-PK', name: 'Urdu' }
            ]
        };

        // Initialize voice features with enhanced error handling
        async function initializeVoiceFeatures() {
            try {
                console.log('🎤 Initializing voice features...');

                // Check for Web Speech API support with detailed logging
                const speechRecognitionSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                const speechSynthesisSupported = 'speechSynthesis' in window;

                console.log('Browser support check:', {
                    speechRecognition: speechRecognitionSupported,
                    speechSynthesis: speechSynthesisSupported,
                    userAgent: navigator.userAgent
                });

                if (!speechRecognitionSupported) {
                    const errorMsg = 'Speech Recognition not supported in this browser. Please use Chrome, Edge, or Safari.';
                    console.warn('❌', errorMsg);
                    showVoiceError(errorMsg);
                    return;
                }

                if (!speechSynthesisSupported) {
                    const errorMsg = 'Speech Synthesis not supported in this browser. Voice output will not work.';
                    console.warn('❌', errorMsg);
                    showVoiceError(errorMsg);
                    // Continue with recognition-only mode
                }

                // Request microphone permission proactively
                try {
                    await requestMicrophonePermission();
                } catch (permissionError) {
                    console.warn('⚠️ Microphone permission request failed:', permissionError);
                    showVoiceError('Microphone permission required for voice features. Please click "Allow" when prompted.');
                }

                // Initialize speech recognition
                initializeSpeechRecognition();

                // Initialize speech synthesis
                initializeSpeechSynthesis();

                // Load available voices with retry
                await loadVoicesWithRetry();

                // Setup voice greeting (only if voice output is enabled)
                if (voiceConfig.voiceGreetingEnabled && voiceState.voiceOutputEnabled) {
                    setTimeout(() => {
                        playGreeting();
                    }, voiceConfig.voiceFeatures.greeting.welcomeDelay);
                }

                // Setup touch-to-speak if enabled
                if (voiceConfig.touchToSpeakEnabled) {
                    setupTouchToSpeak();
                }

                // Initialize voice toggle UI
                updateVoiceToggle();

                console.log('✅ Voice features initialized successfully');

            } catch (error) {
                console.error('❌ Voice initialization failed:', error);
                showVoiceError('Voice initialization failed: ' + error.message);
            }
        }

        // Request microphone permission proactively
        async function requestMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Immediately stop the stream as we only needed permission
                stream.getTracks().forEach(track => track.stop());
                console.log('✅ Microphone permission granted');
                return true;
            } catch (error) {
                console.error('❌ Microphone permission denied:', error);
                throw error;
            }
        }

        // Load voices with retry mechanism
        async function loadVoicesWithRetry(maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    await loadVoices();
                    if (voiceState.voices.length > 0) {
                        console.log(`✅ Voices loaded successfully on attempt ${i + 1}`);
                        return;
                    } else {
                        console.log(`⚠️ No voices loaded on attempt ${i + 1}, retrying...`);
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                } catch (error) {
                    console.error(`❌ Voice loading attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        // Initialize speech recognition with multi-language support
        function initializeSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            voiceState.recognition = new SpeechRecognition();

            voiceState.recognition.continuous = voiceConfig.continuousListening;
            voiceState.recognition.interimResults = true;
            voiceState.recognition.maxAlternatives = 3;

            // Start with English, but allow for language detection
            voiceState.recognition.lang = 'en-US';

            voiceState.recognition.onstart = function() {
                console.log('🎤 Speech recognition started');
                voiceState.isListening = true;
                updateVoiceButtonState();
                showVoiceFeedback('Listening... (English/Urdu)', 'mic');
            };

            voiceState.recognition.onresult = function(event) {
                const result = event.results[event.results.length - 1];
                const transcript = result[0].transcript;

                console.log('🎤 Speech result:', transcript);

                if (result.isFinal) {
                    // Detect language of the input
                    const detectedLanguage = detectSpeechLanguage(transcript);
                    console.log('🎤 Detected language:', detectedLanguage);

                    // Process the command regardless of detected language
                    processVoiceCommand(transcript, detectedLanguage);
                }
            };

            voiceState.recognition.onerror = function(event) {
                console.error('❌ Speech recognition error:', event.error);
                voiceState.isListening = false;
                updateVoiceButtonState();

                let errorMessage = 'Speech recognition error';
                switch(event.error) {
                    case 'no-speech':
                        errorMessage = 'No speech detected';
                        break;
                    case 'audio-capture':
                        errorMessage = 'Microphone not accessible';
                        break;
                    case 'not-allowed':
                        errorMessage = 'Microphone permission denied';
                        break;
                    case 'network':
                        errorMessage = 'Network error occurred';
                        break;
                }
                showVoiceError(errorMessage);
            };

            voiceState.recognition.onend = function() {
                console.log('🎤 Speech recognition ended');
                voiceState.isListening = false;
                updateVoiceButtonState();
                hideVoiceFeedback();
            };
        }

        // Initialize speech synthesis
        function initializeSpeechSynthesis() {
            voiceState.synthesis = window.speechSynthesis;

            // Load voices when they become available
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }
        }

        // Load available voices
        async function loadVoices() {
            return new Promise((resolve) => {
                const loadVoicesInternal = () => {
                    voiceState.voices = speechSynthesis.getVoices();
                    console.log('🎤 Available voices:', voiceState.voices.length);

                    // Select appropriate voice for current language
                    selectVoiceForLanguage(voiceState.currentLanguage);
                    resolve();
                };

                // Voices might not be loaded immediately
                if (speechSynthesis.getVoices().length > 0) {
                    loadVoicesInternal();
                } else {
                    speechSynthesis.addEventListener('voiceschanged', loadVoicesInternal);
                }
            });
        }

        // Select voice for current language
        function selectVoiceForLanguage(language) {
            const languageConfig = voiceConfig.supportedLanguages.find(lang => lang.code === language);
            if (!languageConfig) return;

            // Find matching voice
            let selectedVoice = voiceState.voices.find(voice =>
                voice.lang.startsWith(languageConfig.speechSynthesisVoice)
            );

            // Fallback to default if no match
            if (!selectedVoice) {
                selectedVoice = voiceState.voices.find(voice =>
                    voice.default || voice.lang === 'en-US'
                );
            }

            voiceState.currentVoice = selectedVoice;
            console.log('🎤 Selected voice:', selectedVoice ? selectedVoice.name : 'None');
        }

        // Toggle voice recognition
        function toggleVoiceRecognition() {
            if (!voiceState.recognition) {
                showVoiceError('Speech recognition not available');
                return;
            }

            try {
                if (voiceState.isListening) {
                    voiceState.recognition.stop();
                } else {
                    voiceState.recognition.start();
                }
            } catch (error) {
                console.error('❌ Error toggling voice recognition:', error);
                showVoiceError('Error accessing microphone');
            }
        }

        // Detect language of speech input
        function detectSpeechLanguage(text) {
            const urduPattern = /[\u0600-\u06FF]/; // Urdu/Arabic script range
            const englishPattern = /^[a-zA-Z\s\d\.,!?\-']*$/;

            if (urduPattern.test(text)) {
                return 'ur-PK';
            } else if (englishPattern.test(text)) {
                return 'en-US';
            } else {
                // Mixed or unclear - default to English
                return 'en-US';
            }
        }

        // Enhanced voice command processing with multi-language support
        function processVoiceCommand(command, detectedLanguage = 'en-US') {
            console.log('🎤 Processing voice command:', command, 'Language:', detectedLanguage);

            // Get keywords for the detected language, fallback to English
            const keywords = voiceConfig.voiceFeatures.voiceCommands.keywords[detectedLanguage] ||
                           voiceConfig.voiceFeatures.voiceCommands.keywords['en-US'];

            if (!keywords) {
                console.error('❌ No voice commands configured for detected language:', detectedLanguage);
                // Still process as regular message
                document.getElementById('chatInput').value = command;
                sendMessage();
                return;
            }

            // Convert command to lowercase for matching
            const lowerCommand = command.toLowerCase().trim();

            // Enhanced command matching with fuzzy logic
            const matchedCommand = findBestCommandMatch(lowerCommand, keywords);

            if (matchedCommand) {
                console.log('✅ Command matched:', matchedCommand.type);
                executeVoiceCommand(matchedCommand.type, matchedCommand.confidence, detectedLanguage);
                return;
            }

            // Special handling for voice toggle commands
            if (lowerCommand.includes('voice') && (lowerCommand.includes('on') || lowerCommand.includes('off'))) {
                if (lowerCommand.includes('on') || lowerCommand.includes('enable')) {
                    if (!voiceState.voiceOutputEnabled) {
                        toggleVoiceOutput();
                        return;
                    }
                } else if (lowerCommand.includes('off') || lowerCommand.includes('disable')) {
                    if (voiceState.voiceOutputEnabled) {
                        toggleVoiceOutput();
                        return;
                    }
                }
            }

            // If no command matched, treat as regular message
            console.log('💬 Treating as regular message for current agent');
            document.getElementById('chatInput').value = command;
            sendMessage();
        }

        // Find best command match using fuzzy logic
        function findBestCommandMatch(command, keywords) {
            const commandTypes = ['start', 'stop', 'help', 'repeat', 'home', 'settings'];
            let bestMatch = null;
            let highestConfidence = 0;

            for (const commandType of commandTypes) {
                const commandKeywords = keywords[commandType] || [];

                for (const keyword of commandKeywords) {
                    const similarity = calculateStringSimilarity(command, keyword.toLowerCase());
                    const confidence = similarity;

                    if (confidence > 0.6 && confidence > highestConfidence) { // 60% threshold
                        highestConfidence = confidence;
                        bestMatch = {
                            type: commandType,
                            confidence: confidence,
                            matchedKeyword: keyword
                        };
                    }
                }
            }

            return bestMatch;
        }

        // Calculate string similarity (simple implementation)
        function calculateStringSimilarity(str1, str2) {
            if (str1 === str2) return 1;

            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 0;

            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }

        // Calculate Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        // Execute voice command with confidence feedback
        function executeVoiceCommand(commandType, confidence, detectedLanguage = 'en-US') {
            console.log(`🎯 Executing ${commandType} command with ${Math.round(confidence * 100)}% confidence (Language: ${detectedLanguage})`);

            switch (commandType) {
                case 'start':
                    if (!voiceState.isListening) {
                        toggleVoiceRecognition();
                        if (voiceState.voiceOutputEnabled) {
                            speakText('Voice recognition started');
                        }
                    } else {
                        if (voiceState.voiceOutputEnabled) {
                            speakText('Voice recognition is already active');
                        }
                    }
                    break;

                case 'stop':
                    if (voiceState.isListening) {
                        voiceState.recognition.stop();
                        if (voiceState.voiceOutputEnabled) {
                            speakText('Voice recognition stopped');
                        }
                    } else {
                        if (voiceState.voiceOutputEnabled) {
                            speakText('Voice recognition is not active');
                        }
                    }
                    break;

                case 'help':
                    showVoiceHelp();
                    break;

                case 'repeat':
                    speakLastMessage();
                    break;

                case 'home':
                    selectAgent('sensor');
                    if (voiceState.voiceOutputEnabled) {
                        speakText('Navigated to sensor agent');
                    }
                    break;

                case 'settings':
                    toggleVoiceSettings();
                    if (voiceState.voiceOutputEnabled) {
                        speakText('Voice settings opened');
                    }
                    break;

                case 'voice':
                    // Toggle voice output
                    toggleVoiceOutput();
                    break;
            }
        }

        // Speak text using speech synthesis (only if voice output is enabled)
        function speakText(text, options = {}) {
            // Check if voice output is enabled
            if (!voiceState.voiceOutputEnabled) {
                console.log('🔇 Voice output disabled, skipping speech:', text);
                return;
            }

            if (!voiceState.synthesis || !voiceState.currentVoice) {
                console.warn('❌ Speech synthesis not available');
                return;
            }

            // Stop any current speech
            voiceState.synthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = voiceState.currentVoice;
            utterance.rate = options.rate || 0.9;
            utterance.pitch = options.pitch || 1.0;
            utterance.volume = options.volume || 0.9;

            utterance.onstart = function() {
                voiceState.isSpeaking = true;
                updateVoiceButtonState();
                console.log('🔊 Speaking:', text);
            };

            utterance.onend = function() {
                voiceState.isSpeaking = false;
                updateVoiceButtonState();
                console.log('🔊 Speech completed');
            };

            utterance.onerror = function(event) {
                console.error('❌ Speech synthesis error:', event.error);
                voiceState.isSpeaking = false;
                updateVoiceButtonState();
            };

            voiceState.synthesis.speak(utterance);
        }

        // Play greeting message
        function playGreeting() {
            if (voiceState.greetingPlayed) return;

            const greeting = voiceConfig.voiceFeatures.greeting.messages[voiceState.currentLanguage];
            if (greeting) {
                speakText(greeting);
                voiceState.greetingPlayed = true;
            }
        }

        // Show voice help
        function showVoiceHelp() {
            const currentLang = voiceState.currentLanguage;
            const helpText = currentLang === 'ur-PK'
                ? 'آواز کے احکامات: شروع، رک، مدد، دوبارہ، گھر، سیٹنگز کہہ کر استعمال کریں'
                : 'Voice commands: Say start, stop, help, repeat, home, settings to control the app';

            speakText(helpText);
            addAgentMessage(helpText);
        }

        // Repeat last message
        function speakLastMessage() {
            const messages = document.querySelectorAll('.message.agent .message-text');
            if (messages.length > 0) {
                const lastMessage = messages[messages.length - 1].textContent;
                speakText(lastMessage);
            }
        }

        // Toggle voice output (enable/disable English voice)
        function toggleVoiceOutput() {
            voiceState.voiceOutputEnabled = !voiceState.voiceOutputEnabled;
            updateVoiceToggle();

            if (voiceState.voiceOutputEnabled) {
                console.log('🔊 Voice output enabled');
                // Play a brief confirmation
                speakText('Voice output enabled');
            } else {
                console.log('🔇 Voice output disabled');
                // Stop any current speech
                if (voiceState.synthesis) {
                    voiceState.synthesis.cancel();
                }
            }
        }

        // Get current language code for speech recognition
        function getCurrentLanguageCode() {
            const languageConfig = voiceConfig.supportedLanguages.find(lang => lang.code === voiceState.currentLanguage);
            return languageConfig ? languageConfig.speechRecognitionCode : 'en-US';
        }

        // Update voice toggle UI
        function updateVoiceToggle() {
            const toggle = document.getElementById('voiceToggle');

            if (voiceState.voiceOutputEnabled) {
                toggle.innerHTML = '<span class="material-icons" style="font-size: 14px; margin-right: 4px;">volume_up</span>ON';
                toggle.classList.remove('disabled');
                toggle.classList.add('active');
                toggle.title = 'Voice output is enabled - Click to disable';
            } else {
                toggle.innerHTML = '<span class="material-icons" style="font-size: 14px; margin-right: 4px;">volume_off</span>OFF';
                toggle.classList.remove('active');
                toggle.classList.add('disabled');
                toggle.title = 'Voice output is disabled - Click to enable';
            }
        }

        // Update document language for RTL support
        function updateDocumentLanguage() {
            const currentLang = voiceState.currentLanguage;
            document.documentElement.setAttribute('data-language', currentLang);
            document.documentElement.setAttribute('lang', currentLang);
        }

        // Toggle voice settings panel
        function toggleVoiceSettings() {
            const panel = document.getElementById('voiceSettingsPanel');
            const isVisible = panel.style.display !== 'none';

            if (isVisible) {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateVoiceSettingsDisplay();
            }
        }

        // Update voice settings display with diagnostics
        function updateVoiceSettingsDisplay() {
            // Update voice output status
            const voiceOutputElement = document.getElementById('voiceOutputStatus');
            if (!voiceOutputElement) {
                // Add voice output status if it doesn't exist
                const settingsGrid = document.querySelector('.voice-settings-grid');
                if (settingsGrid) {
                    const voiceOutputDiv = document.createElement('div');
                    voiceOutputDiv.className = 'voice-setting-item';
                    voiceOutputDiv.innerHTML = `
                        <div class="voice-setting-label">Voice Output</div>
                        <div class="voice-setting-value" id="voiceOutputStatus">${voiceState.voiceOutputEnabled ? 'Enabled' : 'Disabled'}</div>
                    `;
                    settingsGrid.appendChild(voiceOutputDiv);
                }
            } else {
                voiceOutputElement.textContent = voiceState.voiceOutputEnabled ? 'Enabled' : 'Disabled';
            }

            // Update voice speed
            const speedElement = document.getElementById('voiceSpeed');
            if (speedElement) {
                speedElement.textContent = 'Normal'; // Could be made configurable
            }

            // Update auto greeting
            const greetingElement = document.getElementById('autoGreeting');
            if (greetingElement) {
                greetingElement.textContent = voiceConfig.voiceGreetingEnabled ? 'Enabled' : 'Disabled';
            }

            // Update touch to speak
            const touchElement = document.getElementById('touchToSpeak');
            if (touchElement) {
                touchElement.textContent = voiceConfig.touchToSpeakEnabled ? 'Enabled' : 'Disabled';
            }

            // Update diagnostic information
            updateVoiceDiagnosticsDisplay();
            updateVoiceCommandsHelp();
        }

        // Update diagnostic display
        function updateVoiceDiagnosticsDisplay() {
            const recognitionStatus = document.getElementById('recognitionStatus');
            const synthesisStatus = document.getElementById('synthesisStatus');
            const availableVoices = document.getElementById('availableVoices');
            const currentVoice = document.getElementById('currentVoice');

            if (recognitionStatus) {
                recognitionStatus.textContent = voiceState.recognition ? 'Ready' : 'Not Available';
                recognitionStatus.style.color = voiceState.recognition ? 'var(--secondary-color)' : 'var(--on-surface-variant)';
            }

            if (synthesisStatus) {
                synthesisStatus.textContent = voiceState.synthesis ? 'Ready' : 'Not Available';
                synthesisStatus.style.color = voiceState.synthesis ? 'var(--secondary-color)' : 'var(--on-surface-variant)';
            }

            if (availableVoices) {
                availableVoices.textContent = voiceState.voices.length > 0 ? `${voiceState.voices.length} voices` : 'Loading...';
            }

            if (currentVoice) {
                currentVoice.textContent = voiceState.currentVoice ? voiceState.currentVoice.name : 'None selected';
            }
        }

        // Update voice commands help display
        function updateVoiceCommandsHelp() {
            const helpElement = document.getElementById('voiceCommandsHelp');
            if (!helpElement) return;

            const keywords = voiceConfig.voiceFeatures.voiceCommands.keywords['en-US'];

            if (!keywords) {
                helpElement.innerHTML = '<span style="color: var(--on-surface-variant);">No voice commands configured</span>';
                return;
            }

            const commands = [
                { command: 'start', keywords: keywords.start, description: 'Start voice recognition (say "start", "begin", "go")' },
                { command: 'stop', keywords: keywords.stop, description: 'Stop voice recognition (say "stop", "end", "finish")' },
                { command: 'voice on', keywords: keywords.voice, description: 'Enable voice output (say "voice on", "enable voice")' },
                { command: 'voice off', keywords: keywords.voice, description: 'Disable voice output (say "voice off", "disable voice")' },
                { command: 'help', keywords: keywords.help, description: 'Show voice commands (say "help", "support")' },
                { command: 'repeat', keywords: keywords.repeat, description: 'Repeat last message (say "repeat", "again")' },
                { command: 'home', keywords: keywords.home, description: 'Go to home screen (say "home", "main")' },
                { command: 'settings', keywords: keywords.settings, description: 'Open voice settings (say "settings", "options")' }
            ];

            const helpHTML = commands.map(cmd => {
                const keywordList = cmd.keywords ? cmd.keywords.slice(0, 3).join(', ') + (cmd.keywords.length > 3 ? '...' : '') : 'Not configured';
                return `<div style="margin-bottom: 6px; padding: 4px; background: var(--surface-variant); border-radius: 4px;">
                    <div style="font-weight: 500; color: var(--on-surface); margin-bottom: 2px;">${cmd.command}</div>
                    <div style="font-size: 10px; color: var(--on-surface-variant); margin-bottom: 2px;"><strong>Examples:</strong> ${keywordList}</div>
                    <div style="font-size: 9px; color: var(--on-surface-variant);">${cmd.description}</div>
                </div>`;
            }).join('');

            helpElement.innerHTML = `
                <div style="margin-bottom: 8px; font-size: 11px; color: var(--secondary-color); font-weight: 500;">
                    🎤 Voice Commands (English/Urdu supported)
                </div>
                ${helpHTML}
                <div style="margin-top: 8px; padding: 6px; background: #e8f5e8; border-radius: 4px; border-left: 3px solid var(--secondary-color);">
                    <div style="font-size: 10px; color: var(--on-surface-variant);">
                        <strong>💡 Tip:</strong> You can speak in English or Urdu, and the system will understand both languages for input while providing English voice output.
                    </div>
                </div>
            `;
        }

        // Setup touch-to-speak functionality
        function setupTouchToSpeak() {
            const overlay = document.getElementById('touchSpeakOverlay');
            const button = document.getElementById('touchSpeakButton');
            const label = document.getElementById('touchSpeakLabel');

            if (!overlay || !button || !label) return;

            // Show overlay on long press or special gesture
            let longPressTimer;

            document.addEventListener('touchstart', (e) => {
                if (voiceState.touchToSpeakMode) return;

                longPressTimer = setTimeout(() => {
                    showTouchToSpeak();
                }, 1000); // 1 second long press
            });

            document.addEventListener('touchend', (e) => {
                clearTimeout(longPressTimer);
            });

            // Handle touch to speak button
            button.addEventListener('click', () => {
                if (voiceState.isListening) {
                    voiceState.recognition.stop();
                    hideTouchToSpeak();
                } else {
                    voiceState.recognition.start();
                    updateTouchSpeakLabel('Listening...');
                }
            });
        }

        // Show touch-to-speak overlay
        function showTouchToSpeak() {
            const overlay = document.getElementById('touchSpeakOverlay');
            const label = document.getElementById('touchSpeakLabel');

            if (overlay && label) {
                voiceState.touchToSpeakMode = true;
                overlay.style.display = 'block';
                updateTouchSpeakLabel('Tap to Speak');
            }
        }

        // Hide touch-to-speak overlay
        function hideTouchToSpeak() {
            const overlay = document.getElementById('touchSpeakOverlay');

            if (overlay) {
                voiceState.touchToSpeakMode = false;
                overlay.style.display = 'none';
            }
        }

        // Update touch-to-speak label
        function updateTouchSpeakLabel(text) {
            const label = document.getElementById('touchSpeakLabel');
            if (label) {
                label.textContent = text;
            }
        }

        // Update voice button states
        function updateVoiceButtonState() {
            const recognitionBtn = document.getElementById('voiceRecognitionBtn');

            if (recognitionBtn) {
                recognitionBtn.classList.remove('active', 'recording', 'speaking');

                if (voiceState.isListening) {
                    recognitionBtn.classList.add('recording');
                } else if (voiceState.isSpeaking) {
                    recognitionBtn.classList.add('speaking');
                } else {
                    recognitionBtn.classList.add('active');
                }
            }
        }

        // Show voice feedback
        function showVoiceFeedback(text, icon) {
            const feedback = document.getElementById('voiceFeedback');
            const feedbackText = document.getElementById('voiceFeedbackText');
            const feedbackIcon = document.getElementById('voiceFeedbackIcon');

            if (feedback && feedbackText && feedbackIcon) {
                feedbackText.textContent = text;
                feedbackIcon.textContent = icon || 'mic';
                feedback.classList.add('show');
            }
        }

        // Hide voice feedback
        function hideVoiceFeedback() {
            const feedback = document.getElementById('voiceFeedback');
            if (feedback) {
                feedback.classList.remove('show');
            }
        }

        // Show voice error
        function showVoiceError(message) {
            showVoiceFeedback('Error: ' + message, 'error');
            setTimeout(hideVoiceFeedback, 3000);
        }

        // Initialize voice features when app starts
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializeVoiceFeatures, 2000); // Delay to ensure everything is loaded
        });

        // ===== ACCESSIBILITY ENHANCEMENTS =====

        // Keyboard navigation for voice controls
        document.addEventListener('keydown', function(e) {
            // Alt + M for voice recognition toggle
            if (e.altKey && e.key === 'm') {
                e.preventDefault();
                toggleVoiceRecognition();
            }

            // Alt + L for language toggle
            if (e.altKey && e.key === 'l') {
                e.preventDefault();
                toggleLanguage();
            }

            // Alt + S for voice settings
            if (e.altKey && e.key === 's') {
                e.preventDefault();
                toggleVoiceSettings();
            }

            // Escape key to stop voice recognition
            if (e.key === 'Escape' && voiceState.isListening) {
                voiceState.recognition.stop();
            }
        });

        // Add ARIA labels and roles
        function enhanceAccessibility() {
            const voiceButton = document.getElementById('voiceRecognitionBtn');
            const languageToggle = document.getElementById('languageToggle');
            const voiceSettingsBtn = document.getElementById('voiceSettingsBtn');

            if (voiceButton) {
                voiceButton.setAttribute('aria-label', 'Toggle voice recognition');
                voiceButton.setAttribute('role', 'button');
            }

            if (languageToggle) {
                languageToggle.setAttribute('aria-label', 'Switch language');
                languageToggle.setAttribute('role', 'button');
            }

            if (voiceSettingsBtn) {
                voiceSettingsBtn.setAttribute('aria-label', 'Voice settings');
                voiceSettingsBtn.setAttribute('role', 'button');
            }

            // Add live region for voice feedback
            const liveRegion = document.createElement('div');
            liveRegion.setAttribute('aria-live', 'polite');
            liveRegion.setAttribute('aria-atomic', 'true');
            liveRegion.setAttribute('aria-label', 'Voice feedback');
            liveRegion.style.position = 'absolute';
            liveRegion.style.left = '-10000px';
            liveRegion.style.width = '1px';
            liveRegion.style.height = '1px';
            liveRegion.style.overflow = 'hidden';
            document.body.appendChild(liveRegion);

            // Store reference for updates
            window.voiceLiveRegion = liveRegion;
        }

        // Haptic feedback for supported devices
        function triggerHapticFeedback() {
            if ('vibrate' in navigator) {
                navigator.vibrate(50); // 50ms vibration
            }
        }

        // Enhanced voice feedback with haptic support
        function showVoiceFeedback(text, icon) {
            const feedback = document.getElementById('voiceFeedback');
            const feedbackText = document.getElementById('voiceFeedbackText');
            const feedbackIcon = document.getElementById('voiceFeedbackIcon');

            if (feedback && feedbackText && feedbackIcon) {
                feedbackText.textContent = text;
                feedbackIcon.textContent = icon || 'mic';
                feedback.classList.add('show');

                // Update live region for screen readers
                if (window.voiceLiveRegion) {
                    window.voiceLiveRegion.textContent = text;
                }

                // Trigger haptic feedback if enabled
                if (voiceConfig.voiceFeatures.touchToSpeak.hapticFeedback) {
                    triggerHapticFeedback();
                }
            }
        }

        // ===== PERFORMANCE OPTIMIZATIONS =====

        // Cache for common phrases
        const phraseCache = new Map();

        // Optimized speak function with caching
        function speakTextOptimized(text, options = {}) {
            // Check cache first
            const cacheKey = text + (options.rate || 0.9) + (options.pitch || 1.0);
            if (phraseCache.has(cacheKey)) {
                console.log('🎤 Using cached speech for:', text);
                return;
            }

            // Cache the utterance
            phraseCache.set(cacheKey, true);

            // Limit cache size
            if (phraseCache.size > 100) {
                const firstKey = phraseCache.keys().next().value;
                phraseCache.delete(firstKey);
            }

            speakText(text, options);
        }

        // Preload common voice responses
        function preloadCommonPhrases() {
            const commonPhrases = [
                'I understand',
                'Please try again',
                'How can I help you?',
                'Processing your request'
            ];

            commonPhrases.forEach(phrase => {
                setTimeout(() => speakTextOptimized(phrase), 100);
            });
        }

        // Adaptive quality based on device performance
        function optimizeForDevice() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                // Fallback for software rendering
                console.log('🔧 Optimizing for software rendering');
                voiceState.synthesis.rate = 0.8; // Slower for better compatibility
            }

            // Check memory constraints
            if (navigator.deviceMemory && navigator.deviceMemory < 2) {
                console.log('🔧 Optimizing for low memory device');
                voiceConfig.continuousListening = false;
            }
        }

        // Background processing for voice data
        function processVoiceInBackground(text) {
            return new Promise((resolve) => {
                // Use requestIdleCallback for non-critical processing
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => {
                        resolve(processVoiceCommand(text));
                    }, { timeout: 1000 });
                } else {
                    setTimeout(() => {
                        resolve(processVoiceCommand(text));
                    }, 0);
                }
            });
        }

        // Enhanced error handling with recovery
        function handleVoiceError(error, context) {
            console.error(`❌ Voice error in ${context}:`, error);

            // Attempt recovery based on error type
            switch (error.type || error.name) {
                case 'not-allowed':
                    showVoiceError('Microphone permission required. Please enable microphone access and refresh the page.');
                    break;
                case 'network':
                    showVoiceError('Network error. Please check your internet connection.');
                    break;
                case 'no-speech':
                    showVoiceError('No speech detected. Please speak clearly and try again.');
                    break;
                default:
                    showVoiceError(`Voice error: ${error.message || 'Unknown error occurred'}`);
            }

            // Auto-retry for certain errors
            if (error.type === 'network' && voiceState.recognition) {
                setTimeout(() => {
                    console.log('🔄 Retrying voice recognition...');
                    voiceState.recognition.start();
                }, 2000);
            }
        }

        // Initialize accessibility enhancements
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                enhanceAccessibility();
                optimizeForDevice();
                preloadCommonPhrases();
            }, 3000);
        });

        // ===== CONTEXTUAL FEATURES =====

        // Smart greetings based on time and context
        function getSmartGreeting() {
            const now = new Date();
            const hour = now.getHours();
            const currentLang = voiceState.currentLanguage;

            let timeOfDay;
            if (hour < 12) timeOfDay = 'morning';
            else if (hour < 17) timeOfDay = 'afternoon';
            else timeOfDay = 'evening';

            const greetings = {
                morning: {
                    'ur-PK': 'صبح بخیر! آج کیا کام ہے؟',
                    'en-US': 'Good morning! What\'s on your farm agenda today?'
                },
                afternoon: {
                    'ur-PK': 'دوپہر بخیر! کیا مدد چاہیے؟',
                    'en-US': 'Good afternoon! How can I help with your farm?'
                },
                evening: {
                    'ur-PK': 'شام بخیر! آج کا کام کیسا رہا؟',
                    'en-US': 'Good evening! How did your farm work go today?'
                }
            };

            return greetings[timeOfDay][currentLang] || greetings[timeOfDay]['en-US'];
        }

        // Enhanced greeting with contextual information
        function playContextualGreeting() {
            if (!voiceConfig.voiceFeatures.greeting.enabled) return;

            const greeting = getSmartGreeting();
            speakText(greeting);

            // Add to chat as well
            setTimeout(() => {
                addAgentMessage(greeting);
            }, 1000);
        }

        // Guided workflow support
        function startGuidedWorkflow(workflowType) {
            const workflows = {
                crop_planning: {
                    'ur-PK': 'فصل کی منصوبہ بندی شروع کرتے ہیں۔ پہلے مجھے بتائیں آپ کون سی فصل اگانا چاہتے ہیں؟',
                    'en-US': 'Let\'s start crop planning. First, tell me what crop would you like to grow?'
                },
                pest_identification: {
                    'ur-PK': 'کیڑوں کی شناخت میں آپ کی مدد کرتا ہوں۔ فصل کا نام اور مسئلہ بتائیں۔',
                    'en-US': 'I\'ll help you identify pests. Tell me the crop name and describe the problem.'
                },
                irrigation_scheduling: {
                    'ur-PK': 'آبپاشی کی منصوبہ بندی کرتے ہیں۔ مٹی کی قسم اور فصل بتائیں۔',
                    'en-US': 'Let\'s plan your irrigation. Tell me the soil type and crop.'
                }
            };

            const message = workflows[workflowType];
            if (message) {
                const currentLang = voiceState.currentLanguage;
                speakText(message[currentLang] || message['en-US']);
                addAgentMessage(message[currentLang] || message['en-US']);
            }
        }

        // ===== TESTING AND DEBUGGING =====

        // Comprehensive voice debugging system
        const voiceDebugger = {
            issues: [],
            warnings: [],
            tests: {},

            // Main diagnostic function
            diagnoseVoiceIssues() {
                console.log('🔍 Starting comprehensive voice diagnostics...');
                this.issues = [];
                this.warnings = [];
                this.tests = {};

                this.testBrowserSupport();
                this.testPermissions();
                this.testVoiceAvailability();
                this.testLanguageSupport();
                this.testInitialization();
                this.testMemoryUsage();

                this.displayResults();
                return {
                    issues: this.issues,
                    warnings: this.warnings,
                    tests: this.tests
                };
            },

            testBrowserSupport() {
                console.log('🌐 Testing browser support...');

                const support = {
                    speechRecognition: 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window,
                    speechSynthesis: 'speechSynthesis' in window,
                    webkitPrefix: 'webkitSpeechRecognition' in window,
                    mediaDevices: 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices
                };

                this.tests.browserSupport = support;

                if (!support.speechRecognition) {
                    this.issues.push({
                        severity: 'critical',
                        category: 'browser_support',
                        message: 'Speech Recognition API not supported in this browser',
                        solution: 'Use Chrome, Edge, or Safari for full voice support'
                    });
                }

                if (!support.speechSynthesis) {
                    this.issues.push({
                        severity: 'high',
                        category: 'browser_support',
                        message: 'Speech Synthesis API not supported',
                        solution: 'Update browser or use Chrome/Edge for voice output'
                    });
                }

                if (!support.mediaDevices) {
                    this.warnings.push({
                        category: 'permissions',
                        message: 'Media devices API not available',
                        solution: 'Microphone access may not work properly'
                    });
                }

                console.log('Browser support test completed:', support);
            },

            testPermissions() {
                console.log('🎤 Testing microphone permissions...');

                if (!navigator.permissions) {
                    this.warnings.push({
                        category: 'permissions',
                        message: 'Permissions API not available in this browser',
                        solution: 'Permission status cannot be checked automatically'
                    });
                    return;
                }

                // Check microphone permission status
                navigator.permissions.query({ name: 'microphone' })
                    .then(permissionStatus => {
                        console.log('Microphone permission status:', permissionStatus.state);

                        if (permissionStatus.state === 'denied') {
                            this.issues.push({
                                severity: 'critical',
                                category: 'permissions',
                                message: 'Microphone permission denied',
                                solution: 'Enable microphone access in browser settings and refresh page'
                            });
                        } else if (permissionStatus.state === 'prompt') {
                            this.warnings.push({
                                category: 'permissions',
                                message: 'Microphone permission needs to be granted',
                                solution: 'Click "Allow" when prompted for microphone access'
                            });
                        }
                    })
                    .catch(error => {
                        console.warn('Permission check failed:', error);
                    });
            },

            testVoiceAvailability() {
                console.log('🎵 Testing voice availability...');

                if (!voiceState.synthesis) {
                    this.issues.push({
                        severity: 'high',
                        category: 'voice_synthesis',
                        message: 'Speech synthesis not initialized',
                        solution: 'Check if voice features were properly initialized'
                    });
                    return;
                }

                const voices = speechSynthesis.getVoices();
                console.log('Available voices:', voices.length);

                this.tests.voiceAvailability = {
                    voicesCount: voices.length,
                    hasUrduVoices: voices.some(v => v.lang.startsWith('ur')),
                    hasEnglishVoices: voices.some(v => v.lang.startsWith('en')),
                    defaultVoice: voices.find(v => v.default)?.name || 'None'
                };

                if (voices.length === 0) {
                    this.warnings.push({
                        category: 'voice_synthesis',
                        message: 'No voices available',
                        solution: 'Voices may load later or browser may not have TTS voices installed'
                    });
                }

                if (!this.tests.voiceAvailability.hasEnglishVoices) {
                    this.warnings.push({
                        category: 'language_support',
                        message: 'No English voices found',
                        solution: 'Install English language pack or use different browser'
                    });
                }

                if (!this.tests.voiceAvailability.hasUrduVoices) {
                    this.warnings.push({
                        category: 'language_support',
                        message: 'No Urdu voices found',
                        solution: 'Install Urdu language pack or use system default'
                    });
                }
            },

            testLanguageSupport() {
                console.log('🌍 Testing language support...');

                const currentLang = voiceState.currentLanguage;
                const languageConfig = voiceConfig.supportedLanguages.find(lang => lang.code === currentLang);

                this.tests.languageSupport = {
                    currentLanguage: currentLang,
                    languageConfig: languageConfig,
                    hasKeywords: !!voiceConfig.voiceFeatures.voiceCommands.keywords[currentLang],
                    hasGreeting: !!voiceConfig.voiceFeatures.greeting.messages[currentLang]
                };

                if (!languageConfig) {
                    this.issues.push({
                        severity: 'high',
                        category: 'language_support',
                        message: `Language configuration missing for: ${currentLang}`,
                        solution: 'Check voiceConfig.supportedLanguages configuration'
                    });
                }

                if (!this.tests.languageSupport.hasKeywords) {
                    this.issues.push({
                        severity: 'medium',
                        category: 'voice_commands',
                        message: `Voice commands not configured for: ${currentLang}`,
                        solution: 'Add voice command keywords for this language'
                    });
                }

                if (!this.tests.languageSupport.hasGreeting) {
                    this.warnings.push({
                        category: 'language_support',
                        message: `Greeting message missing for: ${currentLang}`,
                        solution: 'Add greeting message in voiceConfig.voiceFeatures.greeting.messages'
                    });
                }
            },

            testInitialization() {
                console.log('🚀 Testing initialization status...');

                this.tests.initialization = {
                    recognitionInitialized: !!voiceState.recognition,
                    synthesisInitialized: !!voiceState.synthesis,
                    voicesLoaded: voiceState.voices.length > 0,
                    greetingPlayed: voiceState.greetingPlayed,
                    currentLanguage: voiceState.currentLanguage,
                    isListening: voiceState.isListening,
                    isSpeaking: voiceState.isSpeaking
                };

                if (!voiceState.recognition) {
                    this.issues.push({
                        severity: 'high',
                        category: 'initialization',
                        message: 'Speech recognition not initialized',
                        solution: 'Check initializeSpeechRecognition() function'
                    });
                }

                if (!voiceState.synthesis) {
                    this.issues.push({
                        severity: 'high',
                        category: 'initialization',
                        message: 'Speech synthesis not initialized',
                        solution: 'Check initializeSpeechSynthesis() function'
                    });
                }
            },

            testMemoryUsage() {
                console.log('💾 Testing memory usage...');

                if ('memory' in performance) {
                    const memInfo = performance.memory;
                    this.tests.memoryUsage = {
                        used: Math.round(memInfo.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(memInfo.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(memInfo.jsHeapSizeLimit / 1024 / 1024)
                    };

                    if (memInfo.usedJSHeapSize > memInfo.jsHeapSizeLimit * 0.8) {
                        this.warnings.push({
                            category: 'performance',
                            message: 'High memory usage detected',
                            solution: 'Consider optimizing voice processing or clearing caches'
                        });
                    }
                }
            },

            displayResults() {
                console.log('📊 Voice Diagnostics Results:');
                console.log('Issues found:', this.issues.length);
                console.log('Warnings:', this.warnings.length);
                console.log('Tests completed:', Object.keys(this.tests).length);

                // Display issues in chat
                if (this.issues.length > 0) {
                    const issuesText = this.issues.map(issue =>
                        `${issue.severity.toUpperCase()}: ${issue.message}`
                    ).join('\n');

                    addAgentMessage(`🚨 Voice Issues Detected:\n${issuesText}`);
                }

                if (this.warnings.length > 0) {
                    const warningsText = this.warnings.map(warning =>
                        `⚠️ ${warning.message}`
                    ).join('\n');

                    addAgentMessage(`⚠️ Voice Warnings:\n${warningsText}`);
                }

                if (this.issues.length === 0 && this.warnings.length === 0) {
                    addAgentMessage('✅ Voice system diagnostics passed! All features should work correctly.');
                }

                // Auto-fix critical issues
                this.attemptAutoFixes();
            },

            attemptAutoFixes() {
                console.log('🔧 Attempting automatic fixes...');

                // Fix 1: Reinitialize voice if not properly initialized
                if (!voiceState.recognition || !voiceState.synthesis) {
                    console.log('🔄 Reinitializing voice system...');
                    setTimeout(() => {
                        initializeVoiceWithRetry(1); // Single retry
                    }, 1000);
                }

                // Fix 2: Load voices if not loaded
                if (voiceState.synthesis && voiceState.voices.length === 0) {
                    console.log('🎵 Forcing voice reload...');
                    loadVoices();
                }

                // Fix 3: Reset language if configuration is missing
                const currentLang = voiceState.currentLanguage;
                if (!voiceConfig.voiceFeatures.voiceCommands.keywords[currentLang]) {
                    console.log('🌐 Switching to fallback language...');
                    voiceState.currentLanguage = voiceConfig.fallbackLanguage;
                    updateLanguageToggle();
                }
            }
        };

        // Enhanced voice test function
        function testVoiceFeatures() {
            console.log('🧪 Running comprehensive voice tests...');
            return voiceDebugger.diagnoseVoiceIssues();
        }

        // Make test function globally available
        window.testVoiceFeatures = testVoiceFeatures;

        // Test location detection
        async function testLocationDetection() {
            console.log('🧪 Testing location detection...');

            const testQueries = [
                'Show me agricultural data for Lahore',
                'What are the conditions in Karachi?',
                'Check crop yields in Punjab',
                'Weather information for Islamabad'
            ];

            const results = {
                successful: 0,
                failed: 0,
                tests: []
            };

            for (const query of testQueries) {
                try {
                    console.log(`🧪 Testing query: "${query}"`);

                    // Add the query to chat input and send it
                    const chatInput = document.getElementById('chatInput');
                    chatInput.value = query;
                    const locationDetected = await detectAndProcessLocation(query);

                    if (locationDetected) {
                        results.successful++;
                        results.tests.push({ query, result: 'success' });
                        console.log(`✅ Location detection successful for: "${query}"`);
                    } else {
                        results.failed++;
                        results.tests.push({ query, result: 'failed' });
                        console.log(`❌ Location detection failed for: "${query}"`);
                    }

                    // Wait a bit between tests
                    await new Promise(resolve => setTimeout(resolve, 2000));

                } catch (error) {
                    results.failed++;
                    results.tests.push({ query, result: 'error', error: error.message });
                    console.error(`❌ Error testing query "${query}":`, error);
                }
            }

            console.log('🧪 Location detection test results:', results);

            // Show results in chat
            const successRate = Math.round((results.successful / testQueries.length) * 100);
            let message = `🧪 Location Detection Test Results:\n`;
            message += `✅ Successful: ${results.successful}/${testQueries.length}\n`;
            message += `❌ Failed: ${results.failed}/${testQueries.length}\n`;
            message += `📊 Success Rate: ${successRate}%\n\n`;

            if (results.successful > 0) {
                message += '✅ Location detection is working! Try the example queries above.';
            } else {
                message += '⚠️ Location detection may need troubleshooting. Check the console for details.';
            }

            addAgentMessage(message);

            if (voiceState.isSpeaking) {
                speakText(`Location detection test completed. ${successRate} percent success rate.`);
            }

            return results;
        }

        // Make location test function globally available
        window.testLocationDetection = testLocationDetection;

        // Test map navigation specifically
        async function testMapNavigation() {
            console.log('🧪 Testing map navigation...');

            const testLocations = [
                { name: 'Lahore', coordinates: { lat: 31.5204, lng: 74.3587 } },
                { name: 'Karachi', coordinates: { lat: 24.8607, lng: 67.0011 } },
                { name: 'Islamabad', coordinates: { lat: 33.6846, lng: 73.0479 } }
            ];

            for (const location of testLocations) {
                console.log(`🧪 Testing navigation to: ${location.name}`);
                await navigateMapToLocation(location.coordinates, location.name);

                // Wait between tests
                await new Promise(resolve => setTimeout(resolve, 3000));
            }

            console.log('✅ Map navigation test completed');
        }

        // Make map navigation test globally available
        window.testMapNavigation = testMapNavigation;

        // Debug function to manually test map navigation
        window.debugMapNavigation = function(lat, lng, placeName = 'Test Location') {
            console.log(`🔧 Debug: Manually navigating to ${lat}, ${lng}`);
            navigateMapToLocation({ lat: parseFloat(lat), lng: parseFloat(lng) }, placeName);
        };

        // Debug function to check map status
        window.debugMapStatus = function() {
            console.log('🔧 Debug: Map Status Check');
            console.log('Map exists:', !!map);
            console.log('Google Maps loaded:', !!(window.google && window.google.maps));
            if (map) {
                console.log('Map center:', map.getCenter());
                console.log('Map zoom:', map.getZoom());
                console.log('Map bounds:', map.getBounds());
            }
            return {
                mapExists: !!map,
                googleMapsLoaded: !!(window.google && window.google.maps),
                center: map ? map.getCenter() : null,
                zoom: map ? map.getZoom() : null
            };
        };

        // ===== MAIN WORKFLOW FUNCTIONS =====

        // Step 1: Main search function called when user clicks "Find on Map"
        async function searchLocation() {
            console.log('🔍 Starting AgriSwarm location search workflow...');

            // Get search query from input field
            const locationSearchInput = document.getElementById('location-search');
            const query = locationSearchInput ? locationSearchInput.value.trim() : '';

            if (!query) {
                alert('Please enter a location to search for.');
                return;
            }

            // Show loading state
            const findButton = document.getElementById('find-on-map-btn');
            if (findButton) {
                const originalText = findButton.textContent;
                findButton.textContent = 'Searching...';
                findButton.disabled = true;
                locationSelectionState.isSearching = true;

                try {
                    console.log('📡 Calling backend API for location parsing...');

                    // Step 2: Call backend API (if available)
                    try {
                        const response = await fetch('/api/location/parse', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                query: query
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            console.log('📡 Backend response:', data);

                            // Step 4: Handle successful response
                            if (data.latitude && data.longitude) {
                                console.log('✅ Valid coordinates received from backend');

                                // Move map to location
                                if (map) {
                                    map.setCenter({ lat: data.latitude, lng: data.longitude });
                                    map.setZoom(12);
                                }

                                // Select the location
                                selectLocation(data.latitude, data.longitude);

                                console.log('✅ AgriSwarm location search completed successfully');
                                return;
                            }
                        }
                    } catch (backendError) {
                        console.log('⚠️ Backend API not available, using fallback geocoding');
                    }

                    // Fallback to Google Maps Geocoding
                    console.log('🌐 Attempting Google Maps geocoding for:', query);
                    await fallbackGeocoding(query);

                } catch (error) {
                    console.error('❌ Location search workflow failed:', error);
                    alert('Location search failed. Please try again.');
                } finally {
                    // Restore button state
                    if (findButton) {
                        findButton.textContent = originalText;
                        findButton.disabled = false;
                    }
                    locationSelectionState.isSearching = false;
                }
            }
        }

        // Fallback geocoding using Google Maps Geocoder
        async function fallbackGeocoding(query) {
            console.log('🌐 Attempting Google Maps geocoding for:', query);

            if (!google || !google.maps || !google.maps.Geocoder) {
                console.error('❌ Google Maps Geocoder not available');
                alert('Geocoding service not available. Please check your internet connection.');
                return;
            }

            const geocoder = new google.maps.Geocoder();

            return new Promise((resolve) => {
                geocoder.geocode({ address: query }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        const lat = location.lat();
                        const lng = location.lng();

                        console.log('✅ Geocoding successful:', { lat, lng });

                        // Move map and select location
                        if (map) {
                            map.setCenter({ lat, lng });
                            map.setZoom(12);
                        }
                        selectLocation(lat, lng);

                        resolve({ lat, lng });
                    } else {
                        console.error('❌ Geocoding failed:', status);
                        alert('Location not found. Please try a different search term.');
                        resolve(null);
                    }
                });
            });
        }

        // Step 5: Select location and update UI state
        function selectLocation(lat, lng) {
            console.log('📍 Selecting location:', { lat, lng });

            // Store coordinates globally
            selectedLat = lat;
            selectedLng = lng;
            locationSelectionState.hasSelection = true;

            // Clear old marker
            if (window.currentLocationMarker) {
                window.currentLocationMarker.setMap(null);
            }

            // Add new marker with agriculture symbol
            if (map) {
                const markerPosition = { lat: lat, lng: lng };
                window.currentLocationMarker = new google.maps.Marker({
                    position: markerPosition,
                    map: map,
                    title: 'Selected Farm Location',
                    icon: {
                        path: 'M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z',
                        scale: 2,
                        fillColor: '#34a853',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2,
                        anchor: new google.maps.Point(12, 24)
                    }
                });

                // Add info window
                const infoWindow = new google.maps.InfoWindow({
                    content: `<div style="font-weight: bold; color: #333;">📍 Farm Location</div>
                              <div style="font-size: 12px; color: #666;">Selected for analysis</div>
                              <div style="font-size: 11px; color: #999; font-family: monospace;">${lat.toFixed(4)}, ${lng.toFixed(4)}</div>`
                });

                window.currentLocationMarker.addListener('click', () => {
                    infoWindow.open(map, window.currentLocationMarker);
                });

                // Show info window by default
                setTimeout(() => {
                    infoWindow.open(map, window.currentLocationMarker);
                }, 1000);
            }

            // Update coordinate display
            updateCoordinateDisplay(lat, lng);

            // Enable analysis button
            enableAnalysisButton();

            console.log('✅ Location selection completed');
        }

        // Update coordinate display
        function updateCoordinateDisplay(lat, lng) {
            const coordsDisplay = document.getElementById('selected-coordinates');
            const coordsText = document.getElementById('coords-text');

            if (coordsDisplay && coordsText) {
                coordsText.textContent = `${lat.toFixed(4)}, ${lng.toFixed(4)}`;
                coordsDisplay.style.display = 'block';
            }
        }

        // Enable analysis button
        function enableAnalysisButton() {
            // Add analysis button to map controls if it doesn't exist
            let analysisButton = document.getElementById('analyze-button');
            if (!analysisButton) {
                analysisButton = document.createElement('button');
                analysisButton.id = 'analyze-button';
                analysisButton.className = 'map-control-btn';
                analysisButton.textContent = 'Analyze My Farm';
                analysisButton.style.backgroundColor = 'var(--secondary-color)';
                analysisButton.style.color = 'white';
                analysisButton.onclick = startFarmAnalysis;

                // Add to map controls
                const mapControls = document.querySelector('.map-controls');
                if (mapControls) {
                    mapControls.appendChild(analysisButton);
                }
            }

            // Enable the button
            analysisButton.disabled = false;
            analysisButton.style.opacity = '1';
            analysisButton.style.cursor = 'pointer';
        }

        // Start farm analysis (placeholder function)
        function startFarmAnalysis() {
            if (!selectedLat || !selectedLng) {
                alert('Please select a farm location first.');
                return;
            }

            console.log('🚀 Starting farm analysis for:', { selectedLat, selectedLng });

            // Add analysis message to chat
            addAgentMessage(`🔍 Starting analysis for farm at ${selectedLat.toFixed(4)}, ${selectedLng.toFixed(4)}`);

            // This would typically call backend analysis APIs
            // For now, just show a placeholder response
            setTimeout(() => {
                addAgentMessage('📊 Farm analysis complete! Soil quality: Good, Water availability: Adequate, Recommended crops: Wheat, Maize');
            }, 2000);
        }

        // Alternative Flow: Jump to predefined regions
        function jumpToRegion(lat, lng, regionName) {
            console.log('🗺️ Jumping to region:', regionName, { lat, lng });

            // Move map directly
            if (map) {
                map.setCenter({ lat, lng });
                map.setZoom(12);
            }

            // Select the location
            selectLocation(lat, lng);

            // Update search input
            const locationSearchInput = document.getElementById('location-search');
            if (locationSearchInput) {
                locationSearchInput.value = regionName;
            }

            console.log('✅ Region jump completed');
        }

        // Enhanced intelligent location detection with context awareness
        async function detectAndProcessLocation(message) {
            if (!locationDetectionState.detectionEnabled || locationDetectionState.isProcessing) {
                return false;
            }

            try {
                locationDetectionState.isProcessing = true;
                console.log('🧠 Analyzing message for intelligent location detection:', message);

                // First, determine if this message is likely a location query
                const isLocationQuery = await analyzeMessageIntent(message);

                if (!isLocationQuery.likelyLocationQuery) {
                    console.log('💬 Message is not a location query, treating as regular question');
                    return false;
                }

                console.log('📍 Location query detected, proceeding with geocoding...');

                // Use Google AI Studio to detect and get coordinates for place names
                const locationData = await getLocationFromAIStudio(message);

                if (locationData && locationData.coordinates) {
                    console.log('📍 Location detected:', locationData);

                    // Update map to show the detected location
                    await navigateMapToLocation(locationData.coordinates, locationData.placeName);

                    // Show location detection feedback
                    showLocationDetectionFeedback(locationData);

                    locationDetectionState.lastDetectedLocation = locationData;
                    return true;
                }

                return false;

            } catch (error) {
                console.error('❌ Location detection error:', error);
                return false;
            } finally {
                locationDetectionState.isProcessing = false;
            }
        }

        // Analyze message intent to determine if it's a location query
        async function analyzeMessageIntent(message) {
            const lowerMessage = message.toLowerCase();

            // Direct location indicators
            const directLocationWords = [
                'show me', 'find', 'locate', 'search for', 'look for',
                'where is', 'display', 'map of', 'on the map',
                'agricultural areas in', 'farms in', 'farming in',
                'conditions in', 'weather in', 'soil in'
            ];

            // Location query patterns
            const locationPatterns = [
                /\b(show me|find|locate)\s+(.*)\b/i,
                /\b(in|at|around|near)\s+([a-z\s]+)\b/i,
                /\b([a-z\s]+)\s+(conditions|weather|farms|agriculture)\b/i
            ];

            // Check for direct location indicators
            const hasDirectIndicator = directLocationWords.some(word => lowerMessage.includes(word));

            // Check for location patterns
            const hasLocationPattern = locationPatterns.some(pattern => pattern.test(message));

            // Check for known location names
            const knownLocations = ['lahore', 'karachi', 'islamabad', 'punjab', 'sindh', 'peshawar', 'multan'];
            const hasKnownLocation = knownLocations.some(location => lowerMessage.includes(location));

            // Determine confidence level
            let confidence = 0;
            if (hasDirectIndicator) confidence += 0.4;
            if (hasLocationPattern) confidence += 0.3;
            if (hasKnownLocation) confidence += 0.3;

            const isLocationQuery = confidence > 0.5;

            console.log('🧠 Message intent analysis:', {
                message: message,
                hasDirectIndicator,
                hasLocationPattern,
                hasKnownLocation,
                confidence: Math.round(confidence * 100) + '%',
                isLocationQuery
            });

            return {
                likelyLocationQuery: isLocationQuery,
                confidence: confidence,
                indicators: {
                    hasDirectIndicator,
                    hasLocationPattern,
                    hasKnownLocation
                }
            };
        }

        // Get location data from Google AI Studio API
        async function getLocationFromAIStudio(message) {
            try {
                console.log('🤖 Calling Google AI Studio API for location detection...');

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GOOGLE_AI_STUDIO_API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Extract any place names or locations mentioned in this text and provide their coordinates. Return ONLY a JSON object with this exact format: {"placeName": "extracted place name", "coordinates": {"lat": latitude, "lng": longitude}} or {"placeName": null, "coordinates": null} if no location found. Text: "${message}"`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 100
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`AI Studio API error: ${response.status} - ${response.statusText}`);
                }

                const data = await response.json();
                console.log('🤖 AI Studio response received:', data);

                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const aiResponse = data.candidates[0].content.parts[0].text.trim();
                    console.log('🤖 AI response text:', aiResponse);

                    try {
                        // Try to parse the JSON response from AI
                        const locationResult = JSON.parse(aiResponse);
                        console.log('🤖 Parsed location result:', locationResult);

                        if (locationResult.placeName && locationResult.coordinates) {
                            const coordinates = {
                                lat: parseFloat(locationResult.coordinates.lat),
                                lng: parseFloat(locationResult.coordinates.lng)
                            };

                            // Validate coordinates
                            if (isValidCoordinate(coordinates.lat, coordinates.lng)) {
                                return {
                                    placeName: locationResult.placeName,
                                    coordinates: coordinates,
                                    confidence: 'high',
                                    source: 'ai_studio'
                                };
                            } else {
                                console.warn('⚠️ Invalid coordinates from AI:', coordinates);
                            }
                        }
                    } catch (parseError) {
                        console.warn('⚠️ Failed to parse AI response as JSON:', aiResponse);
                        console.warn('Parse error:', parseError);
                        // Try to extract location using regex fallback
                        return extractLocationWithRegex(message);
                    }
                }

                return null;

            } catch (error) {
                console.error('❌ AI Studio API call failed:', error);
                console.log('🔄 Falling back to regex-based location extraction...');
                // Fallback to regex-based extraction
                return extractLocationWithRegex(message);
            }
        }

        // Validate coordinate values
        function isValidCoordinate(lat, lng) {
            return (
                typeof lat === 'number' && typeof lng === 'number' &&
                lat >= -90 && lat <= 90 &&
                lng >= -180 && lng <= 180 &&
                !isNaN(lat) && !isNaN(lng)
            );
        }

        // Fallback location extraction using regex and known locations
        function extractLocationWithRegex(message) {
            const lowerMessage = message.toLowerCase();

            // Common Pakistani cities and locations
            const knownLocations = {
                'lahore': { lat: 31.5204, lng: 74.3587, name: 'Lahore' },
                'karachi': { lat: 24.8607, lng: 67.0011, name: 'Karachi' },
                'islamabad': { lat: 33.6846, lng: 73.0479, name: 'Islamabad' },
                'rawalpindi': { lat: 33.5651, lng: 73.0169, name: 'Rawalpindi' },
                'peshawar': { lat: 34.0151, lng: 71.5249, name: 'Peshawar' },
                'quetta': { lat: 30.1798, lng: 66.9750, name: 'Quetta' },
                'multan': { lat: 30.1575, lng: 71.5249, name: 'Multan' },
                'faisalabad': { lat: 31.4504, lng: 73.1350, name: 'Faisalabad' },
                'sialkot': { lat: 32.4945, lng: 74.5229, name: 'Sialkot' },
                'gujranwala': { lat: 32.1877, lng: 74.1945, name: 'Gujranwala' },
                'hyderabad': { lat: 25.3960, lng: 68.3578, name: 'Hyderabad' },
                'sukkur': { lat: 27.7054, lng: 68.8574, name: 'Sukkur' },
                'larkana': { lat: 27.5609, lng: 68.2264, name: 'Larkana' },
                'punjab': { lat: 31.1704, lng: 72.7097, name: 'Punjab' },
                'sindh': { lat: 25.8943, lng: 68.5247, name: 'Sindh' },
                'khyber pakhtunkhwa': { lat: 34.9526, lng: 72.3311, name: 'Khyber Pakhtunkhwa' },
                'balochistan': { lat: 28.4907, lng: 65.0960, name: 'Balochistan' }
            };

            // Check for known locations
            for (const [key, location] of Object.entries(knownLocations)) {
                if (lowerMessage.includes(key)) {
                    return {
                        placeName: location.name,
                        coordinates: { lat: location.lat, lng: location.lng },
                        confidence: 'medium'
                    };
                }
            }

            return null;
        }

        // Navigate map to detected location
        async function navigateMapToLocation(coordinates, placeName) {
            try {
                console.log(`🗺️ Navigating map to: ${placeName} (${coordinates.lat}, ${coordinates.lng})`);

                // Ensure map is initialized
                if (!map) {
                    console.warn('⚠️ Map not initialized yet, waiting...');
                    await waitForMapInitialization();
                }

                if (!map) {
                    console.error('❌ Map failed to initialize');
                    return;
                }

                // Validate coordinates
                if (!coordinates || typeof coordinates.lat !== 'number' || typeof coordinates.lng !== 'number') {
                    console.error('❌ Invalid coordinates:', coordinates);
                    return;
                }

                // Create new position with validated coordinates
                const newPosition = new google.maps.LatLng(
                    parseFloat(coordinates.lat),
                    parseFloat(coordinates.lng)
                );

                console.log('📍 Moving map to coordinates:', newPosition.lat(), newPosition.lng());

                // Remove existing location marker
                if (window.currentLocationMarker) {
                    window.currentLocationMarker.setMap(null);
                }

                // Add new location marker first
                window.currentLocationMarker = new google.maps.Marker({
                    position: newPosition,
                    map: map,
                    title: placeName,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 16,
                        fillColor: '#ff6b35',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 3
                    },
                    animation: google.maps.Animation.DROP
                });

                // Add info window
                const infoWindow = new google.maps.InfoWindow({
                    content: `<div style="font-weight: bold; color: #333;">📍 ${placeName}</div>
                              <div style="font-size: 12px; color: #666;">Location detected from your query</div>`
                });

                window.currentLocationMarker.addListener('click', () => {
                    infoWindow.open(map, window.currentLocationMarker);
                });

                // Pan to location with animation
                map.panTo(newPosition);

                // Set zoom level after pan animation completes
                setTimeout(() => {
                    map.setZoom(12);
                    console.log('✅ Map zoom set to level 12');
                }, 500);

                // Show info window after zoom
                setTimeout(() => {
                    infoWindow.open(map, window.currentLocationMarker);
                    console.log('✅ Info window displayed');
                }, 1000);

                // Update map overlay with location info
                updateMapOverlayWithLocation(placeName, coordinates);

                console.log('✅ Map navigation completed successfully');

            } catch (error) {
                console.error('❌ Map navigation error:', error);
                console.error('❌ Error details:', {
                    coordinates: coordinates,
                    placeName: placeName,
                    mapExists: !!map,
                    mapCenter: map ? map.getCenter() : 'N/A'
                });
            }
        }

        // Wait for map initialization
        function waitForMapInitialization() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const checkMap = () => {
                    attempts++;
                    if (map && google && google.maps) {
                        console.log('✅ Map is ready');
                        resolve();
                    } else if (attempts < 50) { // Wait up to 5 seconds
                        setTimeout(checkMap, 100);
                    } else {
                        reject(new Error('Map initialization timeout'));
                    }
                };
                checkMap();
            });
        }

        // Update map overlay with location information
        function updateMapOverlayWithLocation(placeName, coordinates) {
            const overlay = document.getElementById('mapOverlay');
            if (overlay) {
                // Add location info to overlay
                const locationInfo = document.createElement('div');
                locationInfo.className = 'overlay-item';
                locationInfo.innerHTML = `
                    <span class="overlay-label">Detected Location</span>
                    <span class="overlay-value" style="color: #ff6b35;">${placeName}</span>
                `;

                // Clear existing location info
                const existingLocationInfo = overlay.querySelector('.location-info');
                if (existingLocationInfo) {
                    existingLocationInfo.remove();
                }

                // Add new location info at the top
                locationInfo.classList.add('location-info');
                const firstItem = overlay.querySelector('.overlay-item');
                if (firstItem) {
                    overlay.insertBefore(locationInfo, firstItem);
                } else {
                    overlay.appendChild(locationInfo);
                }

                overlay.style.display = 'block';
            }
        }

        // Show location detection feedback
        function showLocationDetectionFeedback(locationData) {
            // Add visual feedback in chat
            const feedbackMessage = `📍 I detected a location in your message: **${locationData.placeName}**. I've updated the map to show this location.`;
            addAgentMessage(feedbackMessage);

            // Show brief notification
            showVoiceFeedback(`📍 Showing ${locationData.placeName} on map`, 'place');

            // Speak the feedback if voice is enabled
            if (voiceState.isSpeaking) {
                speakText(`Location detected: ${locationData.placeName}. Map updated.`);
            }
        }

        // Toggle location detection
        function toggleLocationDetection() {
            locationDetectionState.detectionEnabled = !locationDetectionState.detectionEnabled;
            const status = locationDetectionState.detectionEnabled ? 'enabled' : 'disabled';
            console.log(`🔍 Location detection ${status}`);

            // Update button appearance
            updateLocationDetectionButton();

            if (voiceState.isSpeaking) {
                speakText(`Location detection ${status}`);
            }

            return locationDetectionState.detectionEnabled;
        }

        // Update location detection button state
        function updateLocationDetectionButton() {
            const button = document.getElementById('locationDetectionBtn');
            if (button) {
                button.classList.remove('location-detection-enabled', 'location-detection-disabled');

                if (locationDetectionState.detectionEnabled) {
                    button.classList.add('location-detection-enabled');
                    button.title = 'Location detection is enabled - Click to disable';
                } else {
                    button.classList.add('location-detection-disabled');
                    button.title = 'Location detection is disabled - Click to enable';
                }
            }
        }

        // Initialize location detection button state
        function initializeLocationDetection() {
            updateLocationDetectionButton();
            console.log('🔍 Location detection initialized, enabled by default');
        }

        // Enhanced error recovery
        function initializeVoiceWithRetry(maxRetries = 3) {
            let retries = 0;

            const attemptInitialization = () => {
                initializeVoiceFeatures().catch(error => {
                    retries++;
                    console.error(`❌ Voice initialization attempt ${retries} failed:`, error);

                    if (retries < maxRetries) {
                        console.log(`🔄 Retrying voice initialization in ${retries * 2} seconds...`);
                        setTimeout(attemptInitialization, retries * 2000);
                    } else {
                        console.error('❌ Voice initialization failed after all retries');
                        showVoiceError('Voice features could not be initialized. Please refresh the page.');
                    }
                });
            };

            attemptInitialization();
        }

        // Replace the simple initialization with retry logic
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initializeVoiceWithRetry();
            }, 2000);
        });

        // ===== FINAL INTEGRATION =====

        // Enhanced agent responses with voice
        const originalAddAgentMessage = addAgentMessage;
        addAgentMessage = function(text) {
            originalAddAgentMessage(text);

            // Auto-speak agent responses if voice is active
            if (voiceState.isSpeaking && voiceConfig.accessibilityFeatures.readAloudContent.autoReadImportantInfo) {
                setTimeout(() => {
                    speakText(text);
                }, 500);
            }
        };

        // Enhanced user message processing
        const originalSendMessage = sendMessage;
        sendMessage = function() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();

            if (!message) return;

            // Add user message
            addUserMessage(message);

            // Clear input
            chatInput.value = '';
            chatInput.style.height = 'auto';

            // Disable send button temporarily
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            // Process message based on current agent
            setTimeout(() => {
                processAgentResponse(message);
                sendButton.disabled = false;
            }, 1000);
        };

        // Voice-guided navigation
        function announceNavigation(section) {
            const currentLang = voiceState.currentLanguage;
            const announcements = {
                'sensor': {
                    'ur-PK': 'سینسر ایجنٹ میں خوش آمدید',
                    'en-US': 'Welcome to Sensor Agent'
                },
                'prediction': {
                    'ur-PK': 'پیشگوئی ایجنٹ میں خوش آمدید',
                    'en-US': 'Welcome to Prediction Agent'
                },
                'resource': {
                    'ur-PK': 'وسائل ایجنٹ میں خوش آمدید',
                    'en-US': 'Welcome to Resource Agent'
                },
                'market': {
                    'ur-PK': 'مارکیٹ ایجنٹ میں خوش آمدید',
                    'en-US': 'Welcome to Market Agent'
                }
            };

            const announcement = announcements[section];
            if (announcement) {
                const text = announcement[currentLang] || announcement['en-US'];
                speakText(text);
            }
        }

        // Override selectAgent to include voice announcements
        const originalSelectAgent = selectAgent;
        selectAgent = function(agentType) {
            originalSelectAgent(agentType);
            announceNavigation(agentType);
        };

        console.log('🎤 Web Speech API integration completed successfully!');
    </script>
</body>
</html>